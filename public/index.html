<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3.js Variation Histogram</title>
  <script src="d3.v7.8.5.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
  <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
  <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
  <script src="https://d3js.org/d3.v4.js"></script>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

  <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  
  <style>
    .axis-label {
    cursor: pointer; /* Cursor style when hovering over the axis label */
}

.dragging {
    cursor: move; /* Cursor style during dragging */
}


    #thresholdSlider {
      width: 5%;
    }

    .flex {
  display: flex;
  flex-direction: row;
  max-width: space-between;
  
  }
  .flex-container {
  display: flex;
  flex-direction: column;
  max-width: fit-content;
  
  }

  .flex-container > div {
  margin-right: 20px; /* Add spacing between items */
  }


    body{
      background-color: rgb(230, 220, 220);
    }

    #style_scatter{
      border: 2px solid #ddd; /* Border color */
    border-radius: 8px; /* Border radius for rounded corners */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Shadow effect */
    }


    input.range1 {
  --c: grey; /* active color */
  --l: 8px; /* line thickness */
  --h: 30px; /* thumb height */
  --w: 10px; /* thumb width */

  width: 400px;
  height: var(--h); /* needed for Firefox */
  --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: none;
  cursor: pointer;
  overflow: hidden;
}

input.range1:focus-visible,
input.range1:hover {
  --p: 25%;
}

/* chromium */
input.range1[type="range" i]::-webkit-slider-thumb {
  height: var(--h);
  width: var(--w);
  background: var(--_c);
  border-image: linear-gradient(90deg, var(--_c) 50%, orange 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
  -webkit-appearance: none;
  appearance: none;
  transition: .3s;
}

/* Second range slider with a different color scheme */
input.range2 {
  --c: grey; /* active color */
  --l: 8px; /* line thickness */
  --h: 30px; /* thumb height */
  --w: 10px; /* thumb width */

  width: 400px;
  height: var(--h); /* needed for Firefox */
  --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: none;
  cursor: pointer;
  overflow: hidden;
}

input.range2:focus-visible,
input.range2:hover {
  --p: 25%;
}

/* chromium */
input.range2[type="range" i]::-webkit-slider-thumb {
  height: var(--h);
  width: var(--w);
  background: var(--_c);
  border-image: linear-gradient(90deg, var(--_c) 50%, steelblue 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
  -webkit-appearance: none;
  appearance: none;
  transition: .3s;
}

@supports not (color: color-mix(in srgb,red,red)) {
  input {
    --_c: var(--c);
  }
}

@keyframes pulseAnimation {
  0% {
    fill: green;
    r: 2;
  }
  50% {
    fill: lime; /* Color during the pulse */
    r: 4
  }
  100% {
    fill: green;
    r: 2
  }
}

.pulse {
  animation: pulseAnimation 1s infinite; /* You can adjust the duration as needed */
}


  </style>
</head>
<body>
  
 
  <div class="flex"> <!-- div(1) che mette in colonna-->

  
  <div class="flex-container"><!--div(2) che mette in riga iqr e FC-->
    <div id="style_scatter">
    

    <div id="IQR"></div><!--div(4) IQR-->
    <div> <!--div(3) bottoni IQR-->
      <input type="range" id="thresholdSlider" class="range2" min="0.1" max="0.99" step="0.01" value="0.1" style="width: 200px;">
      <span id="thresholdValue">0.1</span>
    </div><!-- div(3)-->
  <div id="logFCHistogram"></div> <!-- div(5) FC-->

    <div><!-- div(6) bottoni FC-->
      
      <input type="range" id="log_thresholdSlider" class="range1" min="1.1" max="10" step="0.01" value="1.1" style="width: 200px;">
      <span id="log_thresholdSliderValue">1.1</span>
    </div><!--div(6)-->
  </div>
  </div><!--div(2)-->


  <div> 
    <div class="flex-container">
     <div id="style_scatter">
    <div id="scatterPlot"></div>
    <button id="resetButton" class="btn btn-secondary">Reset Zoom</button> 
    <label for="thresholdSelect">Select Threshold:</label>
     <select id="thresholdSelect" class="btn btn-secondary dropdown-toggle">
      <option value="0.05" selected>0.05</option>
    <option value="0.01">0.01</option>
     </select>
  </div> 

  <div id ="checkbox" style="visibility: hidden;">
<input type="checkbox" id="vehicle1" name="vehicle1" value="Age" checked>
<label for="vehicle1"> Age</label>
<input type="checkbox" id="vehicle2" name="vehicle2" value="Smoker">
<label for="vehicle2"> Smoker class</label>
<input type="checkbox" id="vehicle3" name="vehicle3" value="Gender">
<label for="vehicle3"> Gender</label>
</div>
<div id="radiobox" style="visibility: visible;">
  <input type="radio" id="variable1" name="variable" value="case" checked>
  <label for="variable1">Case/Normal</label>

  <input type="radio" id="variable2" name="variable" value="Smoker">
  <label for="variable2">Smoker class</label>

  <input type="radio" id="variable3" name="variable" value="Gender">
  <label for="variable3">Gender</label>
</div>

  <div id="parallelcoordinates"></div>
</div>
</div>


<div>
<div id="style_scatter">
  <div id="boxPlot"></div>
  <!-- Initialize a select button -->
<select id="selectButton" class="btn btn-secondary dropdown-toggle">
  <option value="MostUp" selected>MostUp</option>
  <option value="MostDown">MostdDown</option>
</select>
</div>
</div>


  </div> <!-- div(1)-->
  
  

  
 


  <script>
    try {
        ocpu.seturl("//localhost/ocpu/lib/GEVIS/R");
    } catch (error) {
        // If an error occurs (e.g., ocpu is not defined), reload the page
        window.location.reload();
    }
    let variation_data;
    let variation_data_copy;
    let initial_num_genes;
    let data_upd
    let prc_IQR = 0.1;
    let thr_prc;
    let filteredData;
    let matrix;
    let data_original;
    let dataC_original;
    let dataN_original;
    let data_copy;
    let dataC_copy;
    let dataN_copy;
    let data_copy1;
    let dataC_copy1;
    let dataN_copy1;
    let thr_fc = 1.1;
    let logFC_data;
    let log_thr_fc = Math.log2(thr_fc);
    let parsedLogFC;
    let parsedLogFC_origin;
    let parsedLogFC_origin1;
    let newdataJSON
    let newdataCJSON
    let first_filter_number_genes;
    let p_val_adj;
    let threshold= 0.05;
    let averageExpressions10C;
    let averageExpressions10N;
    let averageExpressionsC;
    let averageExpressionsN;
    let selectedGeneData=[];
    let greencircles = []
    let old_p_adj
    let transposedData = [];
    let ordering
    let metadata;
    let combinedData = []
    let combinedData1 = []

    
    //info box plot
    var sumstat1
    var scatter;
    var sumstat
    var geneNameUP
    var geneNameDown
    /////////

    var first_dims = ['Age at Diagnosis']


    var color_by = 'case'
    
    

    function calculateLogFC(dataC, dataN) {
    const logFCData = [];

    // Iterate over each gene
    Object.keys(dataC).forEach(gene => {
        // Get the values for the current gene from dataC and dataN
        let valuesC = Object.values(dataC[gene]);
        let valuesN = Object.values(dataN[gene]);

        // Pop the last value if it's a gene string
        let geneValueC;
        if (isNaN(valuesC[valuesC.length - 1])) {
            geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
        }
        let geneValueN;
        if (isNaN(valuesN[valuesN.length - 1])) {
            geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
        }

        // Calculate the row mean for dataC and dataN
        const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
        const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

        // Calculate the log fold change
        const logFC = rowMeanC - rowMeanN;

        // Push the gene and its logFC to logFCData
        logFCData.push({ "Gene": geneValueC, "logFC": logFC });
    });

    return logFCData

}


    function fetchJSON(url) {
      return fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          // Rename the key '_row' to 'Gene' in each object of the JSON array
          return data.map(obj => {
            const newObj = { ...obj };
            newObj['gene'] = newObj['_row'];
            delete newObj['_row']; // Delete the old key
            return newObj;
          });
        })
        .catch(error => {
          console.error('Error fetching JSON:', error);
        });
    }

    function fetchMeta(url) {
      return fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .catch(error => {
          console.error('Error fetching JSON:', error);
        });
    }

    // Define a function to fetch data from a file with no header
    function fetchData(filename) {
    return fetch(filename)
    .then(response => response.text())
    .then(text => {
        // Parse the data
        const rows = text.trim().split('\n');
        
        // Extract sample GSM identifiers from the first row (excluding the first element)
        const sampleGSMs = rows[0].trim().split('\t').slice(1);

        // Map each row to an object representing gene expression for each sample
        matrix = rows.slice(1).map(row => {
            const [gene, ...expressions] = row.trim().split('\t');
            
            // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
            return {
                gene: gene,
                expressions: expressions.map(parseFloat)
            };
        });

        // Create a matrix with GSMs as headers
        const matrixWithHeaders = matrix.reduce((result, entry) => {
            const geneObj = {
                Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
            };
            result.push(geneObj);
            return result;
        }, []);
        return matrixWithHeaders; // Return the matrix with headers
    });
  }

  var width = 100,
    height = 100,
    n = 18,
    r = 5,
    π = Math.PI,
    p = 1000;
    const margin = { top: 10, right: 20, bottom: 30, left: 130 };

    var svg = d3.select("#scatterPlot").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("background", "none")
    .attr("transform", `translate(${margin.left},${margin.top})`);

var gScatter = svg.selectAll("g")
    .data(d3.range(0, 2 * π, 2 * π / n))
    .enter().append("g")
    .attr("transform", function(d) {
        var x = width  * (0.35 * Math.cos(d) + 0.5),
            y = height * (0.35 * Math.sin(d) + 0.5);
        return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
    });
var moonsScatter = gScatter.append("path")
    .attr("fill", "#808080");
d3.timer(function(t) {
    var θ = 2 * π * (t % p / p);
    moonsScatter.attr("d", function(d) { return moon((θ + d) % (2 * π)); });
});

const margin1 = { top: 10, right: 20, bottom: 30, left: 5 };
var svg1 = d3.select("#boxPlot").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("background", "none")
    .attr("transform", `translate(${margin1.left},${margin1.top})`);

var gBoxPlot = svg1.selectAll("g")
    .data(d3.range(0, 2 * π, 2 * π / n))
    .enter().append("g")
    .attr("transform", function(d) {
        var x = width  * (0.35 * Math.cos(d) + 0.5),
            y = height * (0.35 * Math.sin(d) + 0.5);
        return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
    });
var moonsBoxPlot = gBoxPlot.append("path")
    .attr("fill", "#808080");
d3.timer(function(t) {
    var θ = 2 * π * (t % p / p);
    moonsBoxPlot.attr("d", function(d) { return moon((θ + d) % (2 * π)); });
});

function moon(θ) {
    var rx0 = θ < π ? r : -r,
        s0  = θ < π ? 0 : 1,
        rx1 = r * Math.cos(θ),
        s1  = θ < π/2 || (π <= θ && θ < 3*π/2) ? 0 : 1;
    return "M" + [0,  r] +
           "A" + [rx0, r, 0, 0, s0, 0, -r] +
           "A" + [rx1, r, 0, 0, s1, 0,  r];
}


    // Read the contents of the .txt file
    Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json'),fetchMeta('metadata.json')])
      .then(([dataC, dataN, data,meta]) => {
        dataC_original = dataC
        dataN_original = dataN
        data_original = data
        metadata=meta
        fetch('variation_lung.txt')
          .then(response => response.text())
          .then(text => {
            // Parse the data
            const rows = text.split('\n');
            variation_data = rows.slice(1).map(row => {
              const [gene, variation] = row.trim().split('\t');
              return parseFloat(variation);
            });
            const row_length= rows.length-1
            initial_num_genes = row_length
            variation_data_copy = (variation_data);
            console.log("numero di geni iniziali prima di qualsiasi filtro "+row_length)

            thr_prc = ss.quantile(variation_data, prc_IQR);
            updateHistogram(variation_data);

            const ind = variation_data_copy.reduce((result, entry, index) => {
              
              if (entry < thr_prc) {
                result.push(index);
              }
              return result;
            }, []);

            if (ind.length > 0) {

              // Remove entries corresponding to ind from dataN
              data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from dataC
              dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from data
              dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from genes
              //genes = genes.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from logFC
              //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            }
            
            dataN_copy=dataN_copy1
            dataC_copy=dataC_copy1
            data_copy=data_copy1
            console.log("geni tolti dal primo filtering del IQR",ind.length)

            // Update the gene count display
            // const geneCountDiv = document.getElementById('geneCount');
            // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

            first_filter_number_genes = data_copy.length

            parsedLogFC_origin1= calculateLogFC(dataC_original,dataN_original)
            parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
            parsedLogFC = parsedLogFC_origin

            //  console.log("first parsed origin after",parsedLogFC_origin.length)
            //  console.log("first data orign afterN ",dataN_copy.length)
            //  console.log("first data orign afterC ",dataC_copy.length)
          
             averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
             averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);


             fetch('genes_and_pval_adj.json')
                .then(response => response.json())
                .then(data => {
                  p_val_adj=data
               
             // Calculate the quantile
        log_thr_fc = Math.log2(1.1);  
        //console.log(log_thr_fc)
        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
            
            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
              result.push(index);
              
            }
            return result;
          }, []);
          console.log("geni tolti dal primo filtering del LOGFC",ind.length)

          // console.log("parsed log before ",parsedLogFC.length)
          // console.log("data copy beforeC ",dataC_copy.length)
          // console.log("data copy beforeN ",dataN_copy.length)

          // console.log("parsed log origin ",parsedLogFC_origin.length)
          /////////////////////// 
          
          //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

          //////////////////////
          // console.log(parsedLogFC_origin)
          // console.log(data_copy)
          if (ind.length>0){

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index)); 
          }

          //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
          // console.log(parsedLogFC)
          // console.log(data_copy)
            
            updateLogFCHistogram(parsedLogFC_origin)
            
              var req = ocpu.call("hello", {
              data: data_copy
          }, function(session) {
              var filteredDataURL = session.loc + "/R/.val/json";
              //console.log(session);
              // Fetch the filtered data from the URL
              fetch(filteredDataURL)
                  .then(response => response.json())
                  .then(data => {
                    old_p_adj=data
                    const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);

        console.log("geni tolti dal primo filtering del pval",ind.length)

        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy.filter((entry, index) => !ind.includes(index));

            console.log("geni rimamenti dal primo filtering",data_copy.length)
            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc,parsedLogFC_origin1,old_p_adj)

            console.log("Promise: al box gli passo parsedlogFC",parsedLogFC.length)
            updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
            updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)


            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

            var mostUpregulatedGene = sortedLogFC[0];
            var secondMostUpregulatedGene = sortedLogFC[1];

            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]

            selectedGeneData.push(mostUpregulatedGeneName)
            selectedGeneData.push(mostDownregulatedGeneName)
            

            
            updateParallel(selectedGeneData,data_copy,dataC_copy,dataN_copy, first_dims)
            scatter.selectAll("circle")
             .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
             .style("fill", d => {
                    // Check if logFC is greater than or equal to the threshold
                    return "green";

                  })
              .classed('pulse',true);


            document.getElementById("checkbox").style.visibility = "visible";
                              }

      });
     
    })
      ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////

            
                  // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);           

          })
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

          // const geneCountDiv2 = document.getElementById('geneCount2');
          // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


          })
          .catch(error => console.error('Error reading file:', error));
        });

    document.getElementById("thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      prc_IQR = parseFloat(this.value);
      document.getElementById("thresholdValue").innerText = prc_IQR;

      // Calculate the quantile
      thr_prc = ss.quantile(variation_data_copy, prc_IQR);
      updateHistogram(variation_data);

      const ind = variation_data_copy.reduce((result, entry, index) => {
        
        if (entry <= thr_prc) {
          result.push(index);
        }
        return result;
      }, []);

      console.log("geni tolti con IQR",ind.length)
      if (ind.length > 0) {
        // Remove entries corresponding to ind from dataC
        dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from data
        dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

        data_copy1  = data_original.filter((entry, index) => !ind.includes(index));
        
        // Remove entries corresponding to ind from genes
        //genes = genes.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from logFC
        //parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

      }
      // Update the gene count display
      // const geneCountDiv = document.getElementById('geneCount');
      // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${dataC_copy1.length}`;

      first_filter_number_genes = dataC_copy.length

      parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
      parsedLogFC = parsedLogFC_origin

      
      //console.log(parsedLogFC_origin)
      updateLogFCHistogram(parsedLogFC_origin)

      
       // Calculate the quantile
       log_thr_fc = Math.log2(thr_fc);  
        //console.log(log_thr_fc)
        const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
            
            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
              result.push(index);
              
            }
            return result;
          }, []);

          console.log("geni da togliere con il logFC da IQR",ind2.length)
          console.log("ora rimuovo questi geni da data che partiva da",data_copy1.length)

          // console.log("parsed log before ",parsedLogFC.length)
          // console.log("data copy beforeC ",dataC_copy.length)
          // console.log("data copy beforeN ",dataN_copy.length)

          // console.log("parsed log origin ",parsedLogFC_origin.length)
          /////////////////////// 
          
          //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

          //////////////////////

          // console.log(parsedLogFC_origin)
          // console.log(data_copy1)

          if (ind2.length>0){
            //console.log("ind2")
            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy1.filter((entry, index) => !ind2.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy1.filter((entry, index) => !ind2.includes(index));

            data_copy = data_copy1.filter((entry, index) => !ind2.includes(index));

            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind2.includes(index)); 
          }

          console.log("ho rimosso",ind2.length," GENI da data e ne rimangono ",data_copy.length)

      // console.log(parsedLogFC)
      // console.log(data_copy)

      // log_thr_fc = Math.log2(thr_fc);  
      //       const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
      //           if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
      //             result.push(index);
      //           }
      //           return result;
      //       }, []);
            

      // const geneCountDiv2 = document.getElementById('geneCount2');
      // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length - ind2.length}`;

    });

    document.getElementById("thresholdSlider").addEventListener("change", function() {

        console.log("data copy in iqr prima di chiamare pval",data_copy)
        var req = ocpu.call("hello", {
              data: data_copy
          }, function(session) {
              var filteredDataURL = session.loc + "/R/.val/json";
              console.log(session);
              // Fetch the filtered data from the URL
              fetch(filteredDataURL)
                  .then(response => response.json())
                  .then(data => {
                    
                    old_p_adj=data
                    
                    averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                    averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                    updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc, parsedLogFC_origin,old_p_adj)
                

                   


                    const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);
        console.log("geni con pval minore di thr nel iqr slider",ind.length)
        console.log("thr pval ",threshold)
        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            console.log("geni passati a box dal IQR slider", parsedLogFC.length)
            updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
            updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)

            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

            var mostUpregulatedGene = sortedLogFC[0];
            var secondMostUpregulatedGene = sortedLogFC[1];

            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
            if (selectedGeneData == []){
              selectedGeneData.push(mostUpregulatedGeneName)
              selectedGeneData.push(mostDownregulatedGeneName)
              
            }
            else{
                // Filter out genes that are not present in dataC_copy or dataN_copy
                selectedGeneData = selectedGeneData.filter(function(gene) {
                // Check if the gene is present in dataC_copy or dataN_copy
                return dataC_copy.some(function(d) { return d.gene === gene; }) ||
                dataN_copy.some(function(d) { return d.gene === gene; });
              });
            }


            
            updateParallel(selectedGeneData,data_copy,dataC_copy,dataN_copy, first_dims)
            scatter.selectAll("circle")
             .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
             .style("fill", d => {
                    // Check if logFC is greater than or equal to the threshold
                    return "green";
                    
                  });
          
          }

      });
    })


       
      // const geneCountDiv2 = document.getElementById('geneCount2');
      // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;

    });


    document.getElementById("log_thresholdSlider").addEventListener("input", function() {
        // Update the threshold value on slider change
        thr_fc = parseFloat(this.value);
        document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

        // Calculate the quantile
        log_thr_fc = Math.log2(thr_fc);  
        //console.log(log_thr_fc)
        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
            
            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
              result.push(index);
              
            }
            return result;
          }, []);

          if (ind.length>0){

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index)); 
          }
  
        updateLogFCHistogram(parsedLogFC_origin);
      
      });

    document.getElementById("log_thresholdSlider").addEventListener("change", function() {

        var req = ocpu.call("hello", {
              data: data_copy
          }, function(session) {
              var filteredDataURL = session.loc + "/R/.val/json";
              console.log(session);
              // Fetch the filtered data from the URL
              fetch(filteredDataURL)
                  .then(response => response.json())
                  .then(data => {
                    old_p_adj=data

                    averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                    averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                    updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc, parsedLogFC_origin,old_p_adj)

                    selectedGeneData = selectedGeneData.filter(function(gene) {
                            // Check if the gene is present in dataC_copy or dataN_copy
                            return dataC_copy.some(function(d) { return d.gene === gene; }) ||
                            dataN_copy.some(function(d) { return d.gene === gene; });
                        });

                    console.log(selectedGeneData)

                    updateParallel(selectedGeneData, data_copy,dataC_copy,dataN_copy, first_dims)                   

                    const ind = old_p_adj.reduce((result, entry, index) => {
          
                    if (entry.pval_adj > threshold) {
                        result.push(index);
                      }
                      return result;
                    }, []);

                    console.log("geni con pval minore di thr nel logFC slider",ind.length)

                    if (ind.length > 0) {

                        //console.log(parsedLogFC.length)

                        // Remove entries corresponding to ind from dataN

                        // Remove entries corresponding to ind from dataN
                        dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                        // Remove entries corresponding to ind from dataN
                        dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                        data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                        // Remove entries corresponding to ind from logFC
                        parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
                        
                        
                        updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
                        updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)
                        
                        selectedGeneData = selectedGeneData.filter(function(gene) {
                            // Check if the gene is present in dataC_copy or dataN_copy
                            return dataC_copy.some(function(d) { return d.gene === gene; }) ||
                            dataN_copy.some(function(d) { return d.gene === gene; });
                        });

                        console.log(selectedGeneData)

                        updateParallel(selectedGeneData, data_copy,dataC_copy,dataN_copy, first_dims)                   

                        
                      }

                  });
                })


       
        //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
        // console.log("parsed log ",parsedLogFC.length)
        // console.log("data copy beforeC ",dataC_copy.length)
        // console.log("data copy beforeN",dataN_copy.length)

        // const geneCountDiv = document.getElementById('geneCount2');
        // geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;
        
        // Now, dataN, dataC, data, genes, and logFC are updated
    })

    // Assuming newdataNJSON, newdataCJSON, and newdataJSON are your arrays of data
    document.getElementById('thresholdSelect').addEventListener('change', function () {
    //console.log(dataC_copy)
    //console.log(data_copy)
    //console.log(dataN_copy)
    
        threshold = parseFloat(this.value);

          const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);

        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

            
            updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
            updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)
                              
          
          }

      })
    
  

    function updateHistogram(variation_data) {
    // Filter data based on the threshold
    const filteredData = variation_data.filter(variation => variation >= thr_prc);

    // Create histogram using D3.js
    const svgWidth = 500;
    const svgHeight = 300;
    const margin = { top: 20, right: 20, bottom: 40, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    const svg = d3.select("#IQR")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram
    const histogram = d3.histogram()
        .value(variation => variation)
        .domain(d3.extent(variation_data))
        .thresholds(100);

    const bins = histogram(variation_data);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(variation_data))
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", d => {
            const thresholdPosition = xScale(thr_prc);
            if (xScale(d.x1) < thresholdPosition) {
                return "grey"; // Set the color to grey if d.x1 is less than the threshold
            } else {
                return "blue"; // Set the original bar color
            }
        });

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(thr_prc);
            return xScale(d.x0); // Start the overlay from the beginning of the bar
        })
        .attr("y", d => yScale(d.length))
        .attr("width", d => {
            const thresholdPosition = xScale(thr_prc);
            const barWidth = xScale(d.x1) - xScale(d.x0);
            if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                // Calculate the width of the portion to color
                return thresholdPosition - xScale(d.x0); // Only color the left portion
            } else {
                return 0; // Set width to 0 for bars where threshold is not in range
            }
        })
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "grey") // Color the left portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale));

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale));


         // Add X axis label
         svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("IQR value");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Frequency");


    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", -margin.top * 0.1)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .text("IQR Frequency distribution");

    // Add a red line indicating the threshold
    const thresholdLine = svg.append("line")
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "darkred")
        .attr("stroke-width", 2);

    // Update the position of the threshold line
    thresholdLine.attr("x1", xScale(thr_prc))
        .attr("x2", xScale(thr_prc));


    // Create a legend
    var legend = svg.append("g")
                .attr("transform", "translate(" + (width -150) + "," + 20 + ")");

            // Add a filter for the shadow
var defs = svg.append("defs");

var filter = defs.append("filter")
    .attr("id", "legendShadow")
    .attr("height", "150%");

filter.append("feGaussianBlur")
    .attr("in", "SourceAlpha")
    .attr("stdDeviation", 3)
    .attr("result", "blur");

filter.append("feOffset")
    .attr("in", "blur")
    .attr("dx", 3)
    .attr("dy", 3)
    .attr("result", "offsetBlur");

var feMerge = filter.append("feMerge");

feMerge.append("feMergeNode")
    .attr("in", "offsetBlur");
feMerge.append("feMergeNode")
    .attr("in", "SourceGraphic");

// Add a rectangle around the legend with shadow
var legendRect = legend.append("rect")
    .attr("x", 5)  // Adjusted x-coordinate to provide some padding
    .attr("y", 5)  // Adjusted y-coordinate to provide some padding
    .attr("width", 160)  // Adjusted width to encapsulate the legend content
    .attr("height", 70)  // Adjusted height to encapsulate the legend content
    .style("stroke", "black")  // Border color
    .style("fill", "none")  // No fill for the rectangle
    .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

// Add Remaining genes
legend.append("rect")
    .attr("x", 10)
    .attr("y", 10)
    .attr("width", 10)
    .attr("height", 10)
    .style("fill", "steelblue");

legend.append("text")
    .attr("x", 30)
    .attr("y", 18)
    .text("Remaining genes")
    .attr("text-anchor", "left")
    .style("alignment-baseline", "middle");

// Add Filtered genes
legend.append("rect")
    .attr("x", 10)
    .attr("y", 35)
    .attr("width", 10)
    .attr("height", 10)
    .style("fill", "grey");

legend.append("text")
    .attr("x", 30)
    .attr("y", 45)
    .text("Filtered genes")
    .attr("text-anchor", "left")
    .style("alignment-baseline", "middle");


}
    
    function updateLogFCHistogram(logFCData) {
    // Extract logFC values and convert them to numbers
    const logFCValues = logFCData.map(entry => entry.logFC);

    // Define histogram parameters
    const svgWidth = 500;
    const svgHeight = 300;
    const margin = { top: 30, right: 20, bottom: 40, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    // Create SVG container
    const svg = d3.select("#logFCHistogram")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram using D3.js
    const histogram = d3.histogram()
        .value(d => d)
        .domain(d3.extent(logFCValues))
        .thresholds(100); // Number of bins

    const bins = histogram(logFCValues);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(logFCValues))
        .nice()
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .nice()
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "orange");

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .append("text")
        .attr("x", width / 2)
        .attr("y", margin.bottom * 0.8)
        .attr("text-anchor", "middle")
        .text("logFC");

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale))
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left * 0.7)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .text("frequency");


        
         // Add X axis label
         svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Log fold change");

            // Add Y axis label
          svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Frequency");



    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", -margin.top * 0.1)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .text("FC (logarithmic) frequency distribution");

    // Add ablines
    svg.append("line")
        .attr("x1", xScale(-Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(-Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "darkred")
        .style("stroke-width", "2");

    svg.append("line")
        .attr("x1", xScale(Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "darkred")
        .style("stroke-width", "2");

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
            return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
        })
        .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
        .attr("width", d => {
            const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
            const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
            const barWidth = xScale(d.x1) - xScale(d.x0);
            // Calculate the width of the portion to color
            return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
        })
        .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
        .attr("fill", "grey") // Color the portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency


    // Create a legend
    var legend = svg.append("g")
                .attr("transform", "translate(" + (width -150) + "," + 20 + ")");

            // Add a filter for the shadow
var defs = svg.append("defs");

var filter = defs.append("filter")
    .attr("id", "legendShadow")
    .attr("height", "150%");

filter.append("feGaussianBlur")
    .attr("in", "SourceAlpha")
    .attr("stdDeviation", 3)
    .attr("result", "blur");

filter.append("feOffset")
    .attr("in", "blur")
    .attr("dx", 3)
    .attr("dy", 3)
    .attr("result", "offsetBlur");

var feMerge = filter.append("feMerge");

feMerge.append("feMergeNode")
    .attr("in", "offsetBlur");
feMerge.append("feMergeNode")
    .attr("in", "SourceGraphic");

// Add a rectangle around the legend with shadow
var legendRect = legend.append("rect")
    .attr("x", 5)  // Adjusted x-coordinate to provide some padding
    .attr("y", 5)  // Adjusted y-coordinate to provide some padding
    .attr("width", 160)  // Adjusted width to encapsulate the legend content
    .attr("height", 70)  // Adjusted height to encapsulate the legend content
    .style("stroke", "black")  // Border color
    .style("fill", "none")  // No fill for the rectangle
    .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

// Add Remaining genes
legend.append("rect")
    .attr("x", 10)
    .attr("y", 10)
    .attr("width", 10)
    .attr("height", 10)
    .style("fill", "orange");

legend.append("text")
    .attr("x", 30)
    .attr("y", 18)
    .text("Remaining genes")
    .attr("text-anchor", "left")
    .style("alignment-baseline", "middle");

// Add Filtered genes
legend.append("rect")
    .attr("x", 10)
    .attr("y", 35)
    .attr("width", 10)
    .attr("height", 10)
    .style("fill", "grey");

legend.append("text")
    .attr("x", 30)
    .attr("y", 45)
    .text("Filtered genes")
    .attr("text-anchor", "left")
    .style("alignment-baseline", "middle");

        

}

    function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

      //console.log(parsed)

      var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
      return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
       }, parsed[0]);

       var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
      return currentGene.logFC < minGene.logFC ? currentGene : minGene;
       }, parsed[0]);

       //console.log(mostUpregulatedGene)
       var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
       var mostDownregulatedGeneName = mostDownregulatedGene.Gene;



            // Set up margin, width, and height
        var margin = { top: 10, right: 150, bottom: 40, left: 60 };
        var width = 1000 - margin.left - margin.right;
        var height = 600 - margin.top - margin.bottom;

        // Create SVG container
        var svg = d3.select("#scatterPlot")
            .html("")  // Clear previous content
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
              
        // Create x and y scales
        var xScale = d3.scaleLinear()
            .domain(d3.extent(Object.values(averageExpressionsN)))
            .range([0, width]);

        var yScale = d3.scaleLinear()
            .domain(d3.extent(Object.values(averageExpressionsC)))
            .range([height, 0])
            .nice()

          
        // Add X axis
        var xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale))

        // Add Y axis
        var yAxis = svg.append("g")
            .call(d3.axisLeft(yScale))
    
        // Customization
        
        var clip = svg.append("defs").append("SVG:clipPath")
            .attr("id", "clip")
            .append("SVG:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

        // Create the scatter variable: where both the circles and the brush take place
        svg.select("#scatter").selectAll("*").remove();
         scatter = svg.append('g')
         .attr("id", "scatter")
            .attr("clip-path", "url(#clip)");

        // Set the zoom and Pan features
        var zoom = d3.zoom()
            .scaleExtent([0.05, 20])
            .extent([[0, 0], [width, height]])
            .on("zoom", updateChart);

        // Add an invisible rect on top of the chart area
        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
            .style("pointer-events", "all")  // Set pointer-events to "all" here
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .lower();

        // Attach zoom behavior to the SVG
        svg.call(zoom);

        // Attach click event to the reset button
        d3.select("#resetButton")
            .on("click", resetZoom);

            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Expression (Normal)");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Expression (Case)");

            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15 )
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatterplot");

            // // Add X axis
            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(xScale));

            // // Add Y axis
            // svg.append("g")
            //     .call(d3.axisLeft(yScale));

            // Create circles for each gene
            var data = Object.keys(averageExpressions10N).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if( logFC <= log_thr_fc ){
                  var type = "down"
                }
                else{
                  var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressions10N[gene], Case: averageExpressions10C[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            // Create a legend
    var legend = svg.append("g")
                .attr("transform", "translate(" + (width -80) + "," + (height-250) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "black")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

              legend.append("circle")
                          .attr("cx", 10)
                          .attr("cy", 20)
                          .attr("r", 3)
                          .style("fill", "darkred");

              legend.append("text")
                  .attr("x", 20)
                  .attr("y", 20)
                  .text("Upregulated")
                  .attr("text-anchor", "left")
                  .style("alignment-baseline", "middle");

                  legend.append("circle")
                          .attr("cx", 10)
                          .attr("cy", 40)
                          .attr("r", 3)
                          .style("fill", "royalblue");

                legend.append("text")
                    .attr("x", 20)
                    .attr("y", 40)
                    .text("Downregulated")
                    .attr("text-anchor", "left")
                    .style("alignment-baseline", "middle");

                    legend.append("circle")
                          .attr("cx", 10)
                          .attr("cy", 65)
                          .attr("r", 3)
                          .style("fill", "grey");

                      legend.append("text")
                          .attr("x", 20)
                          .attr("y", 68)
                          .text("Not Significant");


            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => xScale(d.Normal))
                .attr("cy", d => yScale(d.Case))
                .attr("r", d=>{
                  if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName ) {
                        return "2";
                  }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if(d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if(d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName){
                            return "4"
                    }
                    else if(d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName){
                          return "4"
                    }
                })
                .style("fill", d => {
                 

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene =>  selectedGene === d.gene)){
                      return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene =>  selectedGene === d.gene)){
                      return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        return "royalblue";
                    }  
                    else  {
                        return "grey";
                    }
                })
                .classed('pulse',d =>{
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene =>  selectedGene === d.gene)){
                      return true;
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene =>  selectedGene === d.gene)){
                      return true;
                    }else{
                      return false;
                    }

                })
                .on("mouseover", function (d) {
                  // Highlight the gene on mouseover
                  d3.select(this)
                      .style("stroke", "black")
                      .style("stroke-width", 2);
                    
                  // Display tooltip on mouseover
                  tooltip.transition()
                      .style("opacity", .9);

                  tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toFixed(2) : 'NA'}`)
                      .style("left", (d3.event.pageX + 15) + "px")
                      .style("top", (d3.event.pageY - 28) + "px");
              })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                  var selectedElement = d3.select(this);
                  var currentFill = selectedElement.style("fill");
                  
                  // Check if the element is already filled with grey
                  if (currentFill === "grey") {
                      return; // If grey, do nothing
                  }
                  
                  // Check if the element is already highlighted
                  var isHighlighted = selectedElement.style("fill") === "green";

                  if (isHighlighted) {
                      console.log("sono verde")
                      // If already highlighted, remove the highlighting
                      selectedElement.style("fill",d => {
                      // Check if logFC is greater than or equal to the threshold
                      if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                          return "darkred";
                      } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                          return "royalblue";
                      } else  {
                          return "grey";
                      }

                    })
                    .classed('pulse',false);
                    selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);
                    
                    updateParallel(selectedGeneData,data_copy,dataC_copy,dataN_copy, first_dims)
                    selectedElement.classList.remove('pulse');
                  } else {
                      // If not highlighted, apply the highlighting
                      selectedElement
                          .style("fill", "green")
                          .style("stroke-width", 2)
                          .classed('pulse',true)
                

                      // On click, filter data for the selected gene
                      selectedGeneData.push(d.gene);
                      
                      console.log(selectedGeneData);

                      // Call a function to create parallel coordinates plot using selectedGeneData
                      updateParallel(selectedGeneData,data_copy,dataC_copy,dataN_copy, first_dims)
                  }
                });

            function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(xScale);
            var newY = d3.event.transform.rescaleY(yScale);
            
            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));
            
            // update circle position
            scatter
                .selectAll("circle")
                .attr('cx', function (d) { return newX(d.Normal); })
                .attr('cy', function (d) { return newY(d.Case); });
        }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                  .duration(750)
                  .call(zoom.transform, d3.zoomIdentity);
              }



       
        


        
}

    function createParallelCoordinates(selectedGeneData) {
     // var dataArray = Object.values(selectedGeneData);
      //console.log(dataArray[0]);
      console.log([selectedGeneData]);

        var margin = {top: 30, right: 50, bottom: 10, left: 50},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
          var svg = d3.select("#parallelcoordinates")
          .html("")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");


                  dimensions = ["Normal", "Case","logFC","pval_adj"]
          
        var color=d3.scaleOrdinal().domain(["up","down"]).range(["darkred","royalblue"])


          var highlight = function(d){

            selected_reg= d.type

            // first every group turns grey
            d3.selectAll(".line")
            .transition().duration(200)
            .style("stroke", "lightgrey")
            .style("opacity", "0.2")

            // Second the hovered specie takes its color
            d3.selectAll("." + selected_reg)
            .transition().duration(200)
            .style("stroke", color(selected_reg))
            .style("opacity", "1")

          }

            // Unhighlight
          var doNotHighlight = function(d){
            d3.selectAll(".line")
              .transition().duration(200).delay(1000)
              .style("stroke", function(d){ return( color(d.type))} )
              .style("opacity", "1")
          }

        var y = {}
        for (i in dimensions) {
          name = dimensions[i]
          y[name] = d3.scaleLinear()
            .domain( [-8,8] ) // --> Same axis range for each group
            // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
            .range([height, 0])
        }
          // Build the X scale -> it find the best position for each Y axis
        var x = d3.scalePoint()
          .range([0, width])
          .domain(dimensions)


          function path(d) {
            console.log(d)
            return d3.line()(dimensions.map(function(p,i) { 
              return [  x(p), y[p](d[p])   ];}));
        }

        if(selectedGeneData && selectedGeneData.length > 0){
          console.log(selectedGeneData.length)
        selectedGeneData.forEach(element => {
          svg
        .selectAll("myPath")
        .data(element) // Use the entire array directly
        .enter()
        .append("path")
        .attr("class", function (d) { return "line " + d.type } )
        .style("fill", "none" )
        .style("stroke", function(d){ return( color(d.type))} )
        .style("opacity", 0.5)
        .on("mouseover", highlight)
        .on("mouseleave", doNotHighlight )
        .attr("d", path)
        .on("click", onLineClick); // Add click event to new lines
    });
  }

  


        // Draw the axis:
        svg.selectAll("myAxis")
          // For each dimension of the dataset I add a 'g' element:
          .data(dimensions).enter()
          .append("g")
          .attr("class", "axis")
          // I translate this element to its right position on the x axis
          .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
          // And I build the axis with the call function
          .each(function(d) { d3.select(this).call(d3.axisLeft().ticks(5).scale(y[d])); })
          // Add axis title
          .append("text")
            .style("text-anchor", "middle")
            .attr("y", -9)
            .text(function(d) { return d; })
            .style("fill", "black")

        function onLineClick(d) {
        // Remove the clicked gene from selectedGeneData
        //selectedGeneData = selectedGeneData.filter(gene => gene.gene !== d.gene);
        for (let i = 0; i < selectedGeneData.length; i++) {
          selectedGeneData[i] = selectedGeneData[i].filter(gene => gene.gene !== d.gene);
      }
      //console.log(selectedGeneData)
        // Remove the line from the parallel coordinates plot
        svg.selectAll(".line." + d.type)
            .remove();

        // Remove highlighting color in the scatter plot
         scatter.selectAll("circle")
             .filter(circleData => circleData.gene === d.gene)
             .style("fill", d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        return "royalblue";
                    } else  {
                        return "grey";
                    }
                  });
                  

        // Update parallel coordinates plot
        createParallelCoordinates(selectedGeneData);
    }

        
      }

    function updateBoxPlot(parsedLogFC,dataN,dataC){
      var currentState = "MostUp";
      document.getElementById("selectButton").value = currentState;
      combinedData=[]
      var mostUpregulatedGene = parsedLogFC.reduce((maxGene, currentGene) => {
      return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
       }, parsedLogFC[0]);

    //console.log(mostUpregulatedGene)
     geneNameUP = mostUpregulatedGene.Gene;
    
    // console.log(dataN)  
    // console.log(dataC)
    // console.log(parsedLogFC)


    //console.log(mostUpregulatedGene)

    var geneDataN = dataN.filter(d => d.gene === geneNameUP)
    var geneDataC = dataC.filter(d => d.gene === geneNameUP)

   //console.log()

    

    function computeBoxPlotStatistics(data1) {
          var expressionValues = data1.map(entry => entry.expression);

          // Sort the data for calculating quartiles
          expressionValues.sort((a, b) => a - b);

          // Calculate quartiles and median
          var q1 = d3.quantile(expressionValues, 0.25);
          var q3 = d3.quantile(expressionValues, 0.75);
          var median = d3.median(expressionValues);

          // Calculate interquartile range (IQR)
          var iqr = q3 - q1;


          var min = q1 - 1.5 * iqr
          var max = q3 + 1.5 * iqr

        return {
            q1: q1,
            median: median,
            q3: q3,
            iqr: iqr,
            min: min,
            max: max
        };
    }
    
    let expressionValuesC
      geneDataC.forEach(entry => {
          expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })

        //console.log(expressionValuesC)
          
      let expressionValuesN
      geneDataN.forEach(entry => {
          expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
// Assuming you have expressionValuesC and expressionValuesN

    // Create a new array to store the combined data
     //combinedData;

    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
    expressionValuesC.forEach(expression => {
        combinedData.push({ expression: expression, type: 'case' });
    });

    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
    expressionValuesN.forEach(expression => {
        combinedData.push({ expression: expression, type: 'normal' });
    });
    console.log(combinedData)
    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


     sumstat = d3.nest()
    .key(function(d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
    .rollup(function(d) {
        q1 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.25);
        median = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.5);
        q3 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.75);
        interQuantileRange = q3 - q1;
        min = q1 - 1.5 * interQuantileRange;
        max = q3 + 1.5 * interQuantileRange;

        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
    })
    .entries(combinedData);

    // if{triggered}{

    // var allGroup = ["MostUp", "MostDown"]

    // d3.select("#selectButton")
    //   .selectAll('myOptions')
    //  	.data(allGroup)
    //   .enter()
    // 	.append('option')
    //   .text(function (d) { return d; }) // text showed in the menu
    //   .attr("value", function (d) { return d; }) 
    // }
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
    width = 360 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;


    var svg = d3.select("#boxPlot")
    .html("")  // Clear previous content
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
   
    var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(["normal", "case"])
    .paddingInner(1)
    .paddingOuter(.5)
    
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

    var y = d3.scaleLinear()
    .domain([0,boxPlotStatisticsC.max])
    .range([height, 0])
   svg.append("g").call(d3.axisLeft(y))


   // Add a title
var title = svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top)
    .attr("text-anchor", "middle")
    .style("font-size", "18px")
    .text("Gene "+ geneNameUP);

 
   var line1 =svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 100
  var box1 = svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "#69b3a2")
    var line2 =svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.median))})
      .attr("y2", function(d){return(y(d.value.median))})
      .attr("stroke", "black")
      .style("width", 80)

    var jitterWidth = 50
    var jitter = svg
      .selectAll("indPoints")
      .data(combinedData)
      .enter()
      .append("circle")
        .attr("cx", function(d){return(x(d.type) - jitterWidth/2 + Math.random()*jitterWidth )})
        .attr("cy", function(d){return(y(d.expression))})
        .attr("r", 2)
        .style("fill", "white")
        .attr("stroke", "black")

        function update(selected) {
          console.log(selected)
          var selected1
          if(selected == "MostUp")
          {
            selected1 = sumstat
            genename= geneNameUP
            genestring= "The Most Upregulated Gene "
            console.log("sono mostup")
            combined=combinedData
          }else 
          {
             selected1= sumstat1
             genename= geneNameDown
             genestring= "The Most Downregulated Gene "
             combined=combinedData1
          }

          console.log(selected1)
            line1
            .data(selected1)
            .transition()
            .duration(1000)
            .attr("x1", function(d){return(x(d.key))})
            .attr("x2", function(d){return(x(d.key))})
            .attr("y1", function(d){return(y(d.value.min))})
            .attr("y2", function(d){return(y(d.value.max))})
            .attr("stroke", "black")
            .style("width", 40)

            var boxWidth = 100
            box1
            .data(selected1)
            .transition()
            .duration(1000)
          .attr("x", function(d){return(x(d.key)-boxWidth/2)})
          .attr("y", function(d){return(y(d.value.q3))})
          .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
          .attr("width", boxWidth )
          .attr("stroke", "black")
          .style("fill", "#69b3a2")

          line2
            .data(selected1)
            .transition()
            .duration(1000)
            .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
            .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
            .attr("y1", function(d){return(y(d.value.median))})
            .attr("y2", function(d){return(y(d.value.median))})
            .attr("stroke", "black")
            .style("width", 80)

            title
            .transition()
            .duration(1000)
            .attr("x", width / 2)
            .attr("y", margin.top)
            .attr("text-anchor", "middle")
            .style("font-size", "18px")
            .text("Gene " + genename);

            var jitterWidth = 50
            jitter
            .data(combined)
            .transition()
            .duration(1000)
            .attr("cx", function(d){return(x(d.type) - jitterWidth/2 + Math.random()*jitterWidth )})
            .attr("cy", function(d){return(y(d.expression))})
            .attr("r", 2)
            .style("fill", "white")
            .attr("stroke", "black")


          
        }

        // When the button is changed, run the updateChart function
      d3.select("#selectButton").on("change", function(d) {
        // recover the option that has been chosen
        var selectedOption = d3.select(this).property("value")
        // run the updateChart function with this selected option
        update(selectedOption)
    })
      

  }

    function updateBoxPlot1(parsedLogFC,dataN,dataC){
      combinedData1=[]
    var mostDownregulatedGene = parsedLogFC.reduce((minGene, currentGene) => {
      return currentGene.logFC < minGene.logFC ? currentGene : minGene;
       }, parsedLogFC[0]);

    //console.log(mostUpregulatedGene)
    geneNameDown = mostDownregulatedGene.Gene;
    
    

    var geneDataN = dataN.filter(d => d.gene === geneNameDown)
    var geneDataC = dataC.filter(d => d.gene === geneNameDown)

    

    //  console.log(geneDataC)  
    //  console.log(geneDataC)

        function computeBoxPlotStatistics(data1) {
          var expressionValues = data1.map(entry => entry.expression);

          // Sort the data for calculating quartiles
          expressionValues.sort((a, b) => a - b);

          // Calculate quartiles and median
          var q1 = d3.quantile(expressionValues, 0.25);
          var q3 = d3.quantile(expressionValues, 0.75);
          var median = d3.median(expressionValues);

          // Calculate interquartile range (IQR)
          var iqr = q3 - q1;


          var min = q1 - 1.5 * iqr
          var max = q3 + 1.5 * iqr

        return {
            q1: q1,
            median: median,
            q3: q3,
            iqr: iqr,
            min: min,
            max: max
        };
    }
    let expressionValuesC
      geneDataC.forEach(entry => {
          expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
    let expressionValuesN
      geneDataN.forEach(entry => {
          expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
// Assuming you have expressionValuesC and expressionValuesN

    // Create a new array to store the combined data
     //

    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
    expressionValuesC.forEach(expression => {
        combinedData1.push({ expression: expression, type: 'case' });
    });

    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
    expressionValuesN.forEach(expression => {
        combinedData1.push({ expression: expression, type: 'normal' });
    });

// Now combinedData has the desired structure
    //console.log(combinedData);

   

    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData1);


     sumstat1 = d3.nest()
    .key(function(d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
    .rollup(function(d) {
        q1 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.25);
        median = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.5);
        q3 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.75);
        interQuantileRange = q3 - q1;
        min = q1 - 1.5 * interQuantileRange;
        max = q3 + 1.5 * interQuantileRange;

        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
    })
    .entries(combinedData1);

    // console.log("Q1:", boxPlotStatisticsC.q1);
    // console.log("Q3:", boxPlotStatisticsC.q3);
    // console.log("Median:", boxPlotStatisticsC.median);
    // console.log("IQR:", boxPlotStatisticsC.iqr);
    /*geneDataN.forEach(entry => {
    // Extract the numeric expression values
    var expressionValues = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

    
    // Find the maximum expression value for each gene
    entry.expression = d3.max(expressionValues);

    // Update ymin and ymax based on the current gene's expression value
    ymin = Math.min(ymin, entry.expression);
    ymax = Math.max(ymax, entry.expression);

    });
    */
    
    //console.log(boxPlotStatisticsC)
    
  
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;


    var svg = d3.select("#boxPlot1")
      .html("")  // Clear previous content
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
   
    var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(["normal", "case"])
    .paddingInner(1)
    .paddingOuter(.5)
    
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

    var y = d3.scaleLinear()
    .domain([0,boxPlotStatisticsC.max])
    .range([height, 0])
   svg.append("g").call(d3.axisLeft(y))

    // Add a title
svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top)
    .attr("text-anchor", "middle")
    .style("font-size", "18px")
    .text("The Most Downregulated Gene " + geneNameDown);


   svg
    .selectAll("vertLines")
    .data(sumstat1)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 100
  svg
    .selectAll("boxes")
    .data(sumstat1)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "#69b3a2")

    svg
    .selectAll("medianLines")
    .data(sumstat1)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.median))})
      .attr("y2", function(d){return(y(d.value.median))})
      .attr("stroke", "black")
      .style("width", 80)

    var jitterWidth = 50
    svg
      .selectAll("indPoints")
      .data(combinedData1)
      .enter()
      .append("circle")
        .attr("cx", function(d){return(x(d.type) - jitterWidth/2 + Math.random()*jitterWidth )})
        .attr("cy", function(d){return(y(d.expression))})
        .attr("r", 2)
        .style("fill", "white")
        .attr("stroke", "black")
  }

    
  function updateParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {
    let structureCombinedData = [];

    geneselected.forEach(geneName => {
        var geneDataN = dataN.filter(d => d.gene === geneName);
        var geneDataC = dataC.filter(d => d.gene === geneName);

        // Extract GSM values for each gene
        var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
        var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));

        let expressionValuesC = [];
        geneDataC.forEach(entry => {
            expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
        });

        let expressionValuesN = [];
        geneDataN.forEach(entry => {
            expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
        });

        var combinedData = [];
        expressionValuesC.forEach((expression, i) => {
            combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'case', index: i });
        });
        expressionValuesN.forEach((expression, i) => {
            combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'normal', index: i });
        });

        structureCombinedData.push({
            gene: geneName,
            expressions: combinedData
        });
    });

    //console.log(structureCombinedData);

    // set the dimensions and margins of the graph
    var margin = { top: 30, right: 50, bottom: 10, left: 50 },
        width = 1000 - margin.left - margin.right,
        height = 350 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#parallelcoordinates")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    var selectedVariable = document.querySelector('input[name="variable"]:checked').value;


    var color;
    if (selectedVariable === "case") {
        color = d3.scaleOrdinal()
            .domain(["case", "normal"])
            .range(["lightblue", "darkblue"]);
    } else if (selectedVariable === "Smoker") {
        color = d3.scaleOrdinal()
            .domain(["0", "1", "2"])
            .range(["orange", "brown", "yellow"]);
    } else if (selectedVariable === "Gender") {
        color = d3.scaleOrdinal()
            .domain(["0", "1"])
            .range(["blue", "purple"]);
    }

        var ageAtDiagnosisValues = metadata['Age at Diagnosis:ch1'];

        if (totalOrder !== undefined){
          dimensions = totalOrder
        } else {
          dimensions = first_dims.concat(geneselected);
          
        }
        
    var y = {};
    for (var i in dimensions) {
        var name = dimensions[i];
        y[name] = d3.scaleLinear()
            .domain([0, 20])
            .range([height, 0]);
    }
    // Extract age data from metadata
    var ageData = metadata["Age at Diagnosis:ch1"];
    var genderData = metadata["Gender:ch1"];
    var smokerData = metadata["Cigarette Smoking Status:ch1"];

    // Convert age data to numbers
    ageData = ageData.map(function(age) {
        return parseFloat(age);
    });

    // Determine the age domain
    var ageDomain = d3.extent(ageData);

    // Update the y-scale for the age dimension
    y["Age at Diagnosis"] = d3.scaleLinear()
        .domain([30, 90]) // Set the domain based on the age data
        .range([height, 0]);


    // Update the y-scale for the age dimension
    y["Gender"] = d3.scaleOrdinal()
        .domain(["Male", "Female"]) // Set the domain based on the age data
        .range([height, 0]);




// Update the y-scale for Cigarette Smoking Status
y["Cigarette Smoking Status"] = d3.scaleOrdinal()
    .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
    .range([height, height / 2, 0])
    
    


    // Build the X scale -> it finds the best position for each Y axis
      var x = d3.scalePoint()
      .range([0, width])
      .domain(dimensions);

      //console.log(metadata)



  // Transpose the structureCombinedData
  transposedData = [];
  geneselected.forEach(function(geneName) {
      var geneData = structureCombinedData.find(d => d.gene === geneName);
      geneData.expressions.forEach(function(expression, i) {
          if (!transposedData[i]) transposedData[i] = { GSM: expression.GSM }; // Use GSM value from expression
          transposedData[i][geneName] = expression.expression;
          transposedData[i].type = expression.type; // Add the type property to each observation
          // Find the index of the GSM in the metadata's geo_accession array
          var gsmIndex = metadata.geo_accession.findIndex(item => item === expression.GSM);
          if (gsmIndex !== -1) {
              // If the GSM is found in metadata, insert the corresponding Age at Diagnosis
              transposedData[i]['Age at Diagnosis'] = metadata['Age at Diagnosis:ch1'][gsmIndex];
              transposedData[i]['Gender'] = metadata['Gender:ch1'][gsmIndex];              
              transposedData[i]['Cigarette Smoking Status'] = metadata['Cigarette Smoking Status:ch1'][gsmIndex];              
          }
      });
  });
  //console.log(transposedData);

  svg.selectAll(".gsm-path")
    .data(transposedData)
    .enter()
    .append("path")
    .attr("class", "gsm-path")
    .attr("d", function(d) {
        var pathString = path(d);
        return pathString;
    })
    .style("fill", "none")
    .style("stroke", function(d) {
        if (selectedVariable === "case") {
            return color(d.type);
        } else if (selectedVariable === "Smoker") {
            return color(d['Cigarette Smoking Status']);
        } else if (selectedVariable === "Gender") {
            return color(d['Gender']);
        } else {
            return "black"; // Default color if selected variable doesn't match any condition
        }
    })
    .style("stroke-width", 1); // Example stroke width

  function path(d) {
      return d3.line()(dimensions.map(function(geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
  }
  svg.selectAll(".gsm-path").each(function(data, i) {
      //console.log("Data bound to path " + (i + 1) + ":", data);
  });


    // Draw the axis:
    svg.selectAll("myAxis")
        .data(dimensions).enter()
        .append("g")
        .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
        .each(function (d) { d3.select(this).call(d3.axisLeft().scale(y[d])); })
        .append("text")
        .style("text-anchor", "middle")
        .attr("y", -9)
        .text(function (d) { return d; })
        .style("fill", "black");

    
    // Define drag behavior
    var drag = d3.drag()
        .on("start", dragstart)
        .on("drag", dragmove)
        .on("end", dragend);

    // Draw the axis:
    var axisGroups = svg.selectAll("myAxis")
        .data(dimensions)
        .enter()
        .append("g")
        .attr("class", "axis-group")
        .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
        .each(function (d) { d3.select(this).call(d3.axisLeft().scale(y[d])); })
        .call(drag) // Apply drag behavior to each axis group
        .append("text")
        .attr("class", "dragging") // Add the axis-label class
        .style("text-anchor", "middle")
        .attr("y", -9)
        .text(function (d) { return d; })
        .style("fill", "black");

    // Drag start function
    function dragstart(d) {
        // Raise the dragged axis to the front
        d3.select(this).raise().classed("active", true);
        d3.select(this).classed("dragging", true);

    }

    // Drag move function
    function dragmove(d) {
        // Update the position of the dragged axis
        var newPosition = d3.event.x;
        d3.select(this).attr("transform", "translate(" + newPosition + ")");
    }

    function dragend(d) {
        // Get the new positions of the axis groups
        var newPositions = [];
        svg.selectAll(".axis-group").each(function (d) {
            var transform = d3.select(this).attr("transform");
            var translateX = +transform.split("(")[1].split(")")[0];
            console.log(translateX)
            newPositions.push({ dimension: d, position: translateX });
        });

        // Sort newPositions array based on position
        newPositions.sort(function(a, b) {
            return a.position - b.position;
        });

        // Separate dimensions into geneselected, metadata (first_dims), and total ordering
        var geneselectedOrder = [];
        var metadataOrder = [];
        totalOrder = [];
        newPositions.forEach(function(d) {
            if (geneselected.includes(d.dimension)) {
                geneselectedOrder.push(d.dimension);
            } else if (first_dims.includes(d.dimension)) {
                metadataOrder.push(d.dimension);
            }
            totalOrder.push(d.dimension);
        });

        // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
        var removedDimensions = [];
        newPositions.forEach(function(d) {
            if (d.position < -100 && geneselected.includes(d.dimension)) {
                var index = geneselectedOrder.indexOf(d.dimension);
                if (index !== -1) {
                    removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                    scatter.selectAll("circle")
                        .filter(circleData => circleData.gene === d.dimension)
                        .style("fill", d => {
                                // Check if logFC is greater than or equal to the threshold
                                if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                                    return "darkred";
                                } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                    return "royalblue";
                                } else  {
                                    return "grey";
                                }
                              });
                }
            }
        });

        // Remove corresponding data from transposedData
        transposedData = transposedData.filter(function(d) {
            return !removedDimensions.includes(d.gene);
        });

        // Update totalOrder by removing removedDimensions
        totalOrder = totalOrder.filter(function(d) {
            return !removedDimensions.includes(d);
        });

        console.log("Geneselected order:", geneselectedOrder);
        console.log("Metadata order:", metadataOrder);
        console.log("Total order:", totalOrder);
        console.log("Removed dimensions:", removedDimensions);

        selectedGeneData = geneselectedOrder

        first_dims = metadataOrder

        ordering = totalOrder

        // Update dimensions with new order

        // Redraw the parallel coordinates plot
        // Call updateParallel or relevant function here with updated dimensions
        updateParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
        updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc,parsedLogFC,old_p_adj)
        d3.selectAll(".axis-label").classed("dragging", false);

    }
    var newPositions = [];
    svg.selectAll(".axis-group").each(function (d) {
        var transform = d3.select(this).attr("transform");
        var translateX = +transform.split("(")[1].split(")")[0];
        console.log(translateX)
        newPositions.push({ dimension: d, position: translateX });
    });
    console.log(newPositions)

    // Sort newPositions array based on position
    newPositions.sort(function(a, b) {
        return a.position - b.position;
    });

    // Separate dimensions into geneselected, metadata (first_dims), and total ordering
    var geneselectedOrder = [];
    var metadataOrder = [];
    totalOrder = [];
    newPositions.forEach(function(d) {
        if (geneselected.includes(d.dimension)) {
            geneselectedOrder.push(d.dimension);
        } else if (first_dims.includes(d.dimension)) {
            metadataOrder.push(d.dimension);
        }
        totalOrder.push(d.dimension);
    });

    // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
    var removedDimensions = [];
    newPositions.forEach(function(d) {
        if (d.position < -100 && geneselected.includes(d.dimension)) {
            var index = geneselectedOrder.indexOf(d.dimension);
            if (index !== -1) {
                removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                        // Remove highlighting color in the scatter plot
                scatter.selectAll("circle")
                    .filter(circleData => circleData.gene === d.dimension)
                    .style("fill", d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else  {
                                return "grey";
                            }
                          });
            }
        }
    });

    // Remove corresponding data from transposedData
    transposedData = transposedData.filter(function(d) {
        return !removedDimensions.includes(d.gene);
    });

    // Update totalOrder by removing removedDimensions
    totalOrder = totalOrder.filter(function(d) {
        return !removedDimensions.includes(d);
    });

    console.log("Geneselected order:", geneselectedOrder);
    console.log("Metadata order:", metadataOrder);
    console.log("Total order:", totalOrder);
    console.log("Removed dimensions:", removedDimensions);

    selectedGeneData = geneselectedOrder

    first_dims = metadataOrder

    ordering = totalOrder

// Function to handle mouseover event
function highlight(d) {
    // Determine the value to highlight based on the selected variable
    var selected_reg;
    if (selectedVariable === "case") {
        selected_reg = d.type;
    } else if (selectedVariable === "Smoker") {
        selected_reg = d['Cigarette Smoking Status'];
    } else if (selectedVariable === "Gender") {
        selected_reg = d['Gender'];
    } else {
        selected_reg = ""; // Set default value
    }

    // First, every group turns grey
    d3.selectAll(".gsm-path")
        .transition().duration(200)
        .style("stroke", function(data) {
            // Highlight only the selected category, reduce opacity for others
            if (selectedVariable === "case") {
                return data.type === selected_reg ? color(selected_reg) : "lightgrey";
            } else if (selectedVariable === "Smoker") {
                return data['Cigarette Smoking Status'] === selected_reg ? color(selected_reg) : "lightgrey";
            } else if (selectedVariable === "Gender") {
                return data['Gender'] === selected_reg ? color(selected_reg) : "lightgrey";
            } else {
                return "lightgrey"; // Default stroke color
            }
        })
        .style("opacity", function(data) {
            // Set opacity based on whether it's the selected category or not
            if (selectedVariable === "case") {
                return data.type === selected_reg ? "1" : "0.2";
            } else if (selectedVariable === "Smoker") {
                return data['Cigarette Smoking Status'] === selected_reg ? "1" : "0.2";
            } else if (selectedVariable === "Gender") {
                return data['Gender'] === selected_reg ? "1" : "0.2";
            } else {
                return "1"; // Default stroke color
            }
        });
    }

    // Function to handle mouseout event
    function doNotHighlight() {
        // Reset stroke color and opacity for all lines
        d3.selectAll(".gsm-path")
            .transition().duration(200)
            .style("stroke", function(data) {
                // Set stroke color based on the selected variable
                if (selectedVariable === "case") {
                    return color(data.type);
                } else if (selectedVariable === "Smoker") {
                    return color(data['Cigarette Smoking Status']);
                } else if (selectedVariable === "Gender") {
                    return color(data['Gender']);
                } else {
                    return "black"; // Default stroke color
                }
            })
            .style("opacity", "1"); // Reset opacity to 1
    }

    // Bind mouseover and mouseleave events to all lines
    svg.selectAll(".gsm-path")
        .on("mouseover", highlight)
        .on("mouseleave", doNotHighlight);

}

    function calculateAverageExpressions(dataArray) {
      // Create an object to store the sum and count for each gene
      var geneSumCount = {};

      // Iterate through each gene object in the array
      dataArray.forEach(function (geneData) {
          var gene = geneData.gene;

          // Iterate through each property (sample) in the gene object
          for (var sample in geneData) {
              if (sample !== 'gene') {
                  // If the gene is not in the sumCount object, initialize it
                  if (!geneSumCount[gene]) {
                      geneSumCount[gene] = { sum: 0, count: 0 };
                  }

                  // Add the expression value to the sum and increment the count
                  geneSumCount[gene].sum += parseFloat(geneData[sample]);
                  geneSumCount[gene].count++;
              }
          }
      });

      // Calculate the average for each gene
      var averageExpressions = {};
      for (var gene in geneSumCount) {
          averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
      }

      return averageExpressions;
  }

    function calculateAverageLog10Expressions(dataArray) {
    // Create an object to store the sum and count for each gene
    var geneSumCount = {};

    // Iterate through each gene object in the array
    dataArray.forEach(function (geneData) {
        var gene = geneData.gene;

        // Iterate through each property (sample) in the gene object
        for (var sample in geneData) {
            if (sample !== 'gene') {
                // If the gene is not in the sumCount object, initialize it
                if (!geneSumCount[gene]) {
                    geneSumCount[gene] = { sum: 0, count: 0 };
                }

                // Apply Math.log10 to the expression value before summing
                var log10Expression = Math.log2(parseFloat(geneData[sample]));

                // Add the log10 expression value to the sum and increment the count
                geneSumCount[gene].sum += log10Expression;
                geneSumCount[gene].count++;
            }
        }
    });

    // Calculate the average log10 expression for each gene
    var averageLog10Expressions = {};
    for (var gene in geneSumCount) {
        averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
    }

    return averageLog10Expressions;
}

// Function to handle checkbox change event
function handleCheckboxChange() {
    var checkbox = document.getElementById("vehicle1");
    var isChecked = checkbox.checked;

    if (isChecked) {
        // Add 'Age at Diagnosis' dimension to dimensions array
        first_dims.unshift('Age at Diagnosis');
    } else {
        // Remove 'Age at Diagnosis' dimension from dimensions array
        var index = first_dims.indexOf('Age at Diagnosis');
        if (index !== -1) {
            first_dims.splice(index, 1);
            if (first_dims===undefined){
              first_dims=[]
            }
        }
    }

    // Call updateParallel with the updated dimensions array
    updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
}

// Function to handle checkbox change event
function handleCheckboxChangeGender() {
    var checkbox = document.getElementById("vehicle3");
    var isChecked = checkbox.checked;

    if (isChecked) {
        // Add 'Age at Diagnosis' dimension to dimensions array
        first_dims.unshift('Gender');
    } else {
        // Remove 'Age at Diagnosis' dimension from dimensions array
        var index = first_dims.indexOf('Gender');
        if (index !== -1) {
            first_dims.splice(index, 1);
            if (first_dims===undefined){
              first_dims=[]
            }
        }
    }

    // Call updateParallel with the updated dimensions array
    updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
}

// Function to handle checkbox change event
function handleCheckboxChangeCigarettes() {
    var checkbox = document.getElementById("vehicle2");
    var isChecked = checkbox.checked;

    if (isChecked) {
        // Add 'Age at Diagnosis' dimension to dimensions array
        first_dims.unshift('Cigarette Smoking Status');
    } else {
        // Remove 'Age at Diagnosis' dimension from dimensions array
        var index = first_dims.indexOf('Cigarette Smoking Status');
        if (index !== -1) {
            first_dims.splice(index, 1);
            if (first_dims===undefined){
              first_dims=[]
            }
        }
    }

    // Call updateParallel with the updated dimensions array
    updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
}

// Attach event listener to the checkbox
document.getElementById("vehicle1").addEventListener("change", handleCheckboxChange);
document.getElementById("vehicle3").addEventListener("change", handleCheckboxChangeGender);
document.getElementById("vehicle2").addEventListener("change", handleCheckboxChangeCigarettes);


var radioInputs = document.querySelectorAll('input[type="radio"]');

// Define a function to update colors
function updateColors(selectedVariable) {
    var color;
    if (selectedVariable === "case") {
        color = d3.scaleOrdinal()
            .domain(["case", "normal"])
            .range(["lightblue", "darkblue"]);
    } else if (selectedVariable === "Smoker") {
        color = d3.scaleOrdinal()
            .domain(["0", "1", "2"])
            .range(["orange", "brown", "yellow"]);
    } else if (selectedVariable === "Gender") {
        color = d3.scaleOrdinal()
            .domain(["0", "1"])
            .range(["blue", "purple"]);
    }
    return color;
}

// Call the updateColors function when a radio box is selected
radioInputs.forEach(function(input) {
    input.addEventListener('change', function() {
      console.log(this.value)
        var selectedVariable = this.value;
        console.log("Geneselected order in radio:", selectedGeneData);
        console.log("Metadata order in radio:", first_dims);
        console.log("Total order in radio:", ordering);

        updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
    });
});


  </script>
 
<div id="tooltip" style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px;"></div>
<div id="tTestResults"></div>



</body>
</html>

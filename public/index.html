<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3.js Variation Histogram</title>
  <script src="d3.v7.8.5.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
  <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
  <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
  <style>
    #thresholdSlider {
      width: 10%;
    }
  </style>
</head>
<body>
  
  <h2>IQR frequency distribution</h2>
  <div>
    <label for="thresholdSlider">InterQuantile range:</label>
    <input type="range" id="thresholdSlider" min="0.1" max="1" step="0.01" value="0.1">
    <span id="thresholdValue">0.1</span>
  </div>
  <div id="IQR">
  </div>

  <h2>LogFC Histogram</h2>
  <div>
    <label for="log_thresholdSlider">LogFC threshold:</label>
    <input type="range" id="log_thresholdSlider" min="1.1" max="10" step="0.01" value="1.1">
    <span id="log_thresholdSliderValue">1.1</span>
  </div>

  <div id="logFCHistogram">
  </div>

  <script>
    // Your existing JavaScript code goes here
    // Make sure to include the necessary libraries and define variables as needed

    function updateLogFCHistogram(logFCData) {
    // Extract logFC values and convert them to numbers
    const logFCValues = logFCData.map(entry => entry.logFC);

    // Define histogram parameters
    const svgWidth = 900;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 50, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    // Create SVG container
    const svg = d3.select("#logFCHistogram")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram using D3.js
    const histogram = d3.histogram()
        .value(d => d)
        .domain(d3.extent(logFCValues))
        .thresholds(100); // Number of bins

    const bins = histogram(logFCValues);

    // Debugging: Log histogram bins
    console.log("Histogram bins:", bins);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(logFCValues))
        .nice()
        .range([0, width]);

    // Debugging: Log x-axis domain
    console.log("X-axis domain:", xScale.domain());

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .nice()
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "orange");

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .append("text")
        .attr("x", width / 2)
        .attr("y", margin.bottom * 0.8)
        .attr("text-anchor", "middle")
        .text("logFC");

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale))
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left * 0.7)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .text("frequency");

    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", -margin.top * 0.7)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .text("FC (logarithmic) frequency distribution");

    // Add ablines
    svg.append("line")
        .attr("x1", xScale(-Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(-Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    svg.append("line")
        .attr("x1", xScale(Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
            return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
        })
        .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
        .attr("width", d => {
            const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
            const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
            const barWidth = xScale(d.x1) - xScale(d.x0);
            // Calculate the width of the portion to color
            return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
        })
        .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
        .attr("fill", "grey") // Color the portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency
}


    </script>


  <script>
    ocpu.seturl("//localhost/ocpu/lib/GEVIS/R")
    let data
    let data_upd
    let prc_IQR = 0.1;
    let thr_prc;
    let filteredData;
    let matrix;
    let dataC;
    let dataN;
    let thr_fc = 1.1;
    let logFC_data;
    let log_thr_fc = Math.log2(thr_fc);
    let parsedLogFC;
    let parsedLogFC_origin;
    let newdataJSON
    let newdataCJSON
    let newdataNJSON


    // Define a function to fetch data from a file with no header
    function fetchData(filename) {
    return fetch(filename)
    .then(response => response.text())
    .then(text => {
        // Parse the data
        const rows = text.trim().split('\n');
        
        // Extract sample GSM identifiers from the first row (excluding the first element)
        const sampleGSMs = rows[0].trim().split('\t').slice(1);

        // Map each row to an object representing gene expression for each sample
        matrix = rows.slice(1).map(row => {
            const [gene, ...expressions] = row.trim().split('\t');
            
            // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
            return {
                gene: gene,
                expressions: expressions.map(parseFloat)
            };
        });

        // Create a matrix with GSMs as headers
        const matrixWithHeaders = matrix.reduce((result, entry) => {
            const geneObj = {
                Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
            };
            result.push(geneObj);
            return result;
        }, []);
        return matrixWithHeaders; // Return the matrix with headers
    });
  }


    // Read the contents of the .txt file
    fetch('variation_lung.txt')
      .then(response => response.text())
      .then(text => {
        // Parse the data
        const rows = text.split('\n');
         data = rows.slice(1).map(row => {
          const [gene, variation] = row.trim().split('\t');
          

          return parseFloat(variation);
        });
        const row_length= rows.length-1
        console.log("numero di geni iniziali prima di qualsiasi filtro "+row_length)
       thr_prc = ss.quantile(data, prc_IQR);
      })
      .catch(error => console.error('Error reading file:', error));

      

    document.getElementById("thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      prc_IQR = parseFloat(this.value);
      document.getElementById("thresholdValue").innerText = prc_IQR;

      // Calculate the quantile
      thr_prc = ss.quantile(data, prc_IQR);
        
      // Call the updateHistogram function directly
      updateHistogram();

    });

    document.getElementById("thresholdSlider").addEventListener("change", function() {

      Promise.all([fetchData('dataC_log.txt'), fetchData('dataN_log.txt')])
      .then(([dataC, dataN]) => {
        console.log(dataC)

      fetch('matrix.txt')
      .then(response => response.text())
      .then(text => {
          // Parse the data
          const rows = text.trim().split('\n');
          
          // Extract sample GSM identifiers from the first row (excluding the first element)
          const sampleGSMs = rows[0].trim().split('\t').slice(1);

          // Map each row to an object representing gene expression for each sample
          matrix = rows.slice(1).map(row => {
              const [gene, ...expressions] = row.trim().split('\t');
              
              // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
              return {
                  gene: gene,
                  expressions: expressions.map(parseFloat)
              };
          });

          // Create a matrix with GSMs as headers
          const matrixWithHeaders = matrix.reduce((result, entry) => {
              const geneObj = {
                  Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                  ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
              };
              result.push(geneObj);
              return result;
          }, []);

        // console.log("Sample GSMs:", sampleGSMs);
          console.log("Matrix with Headers:", matrixWithHeaders);

      
        console.log(thr_prc)
        var req = ocpu.call("hello", {
            variation: data,
            data: matrixWithHeaders,
            dataC: dataC,
            dataN: dataN,
            thr_prc: thr_prc
        }, function(session) {
            var filteredDataURL = session.loc + "/R/.val/json";
            console.log(session);
            // Fetch the filtered data from the URL
            fetch(filteredDataURL)
                .then(response => response.json())
                .then(data => {
                    // Extract data from the JSON response
                    const { newdata, newdataC, newdataN, logFC } = data;
                    logFC_data = logFC

                    newdataJSON=newdata
                    newdataCJSON=newdataC
                    newdataNJSON=newdataN
                    // Now you have parsed the data into JavaScript objects
                    console.log("Parsed newdata: ", newdataJSON);
                    console.log("Parsed newdataC: ", newdataCJSON);
                    console.log("Parsed newdataN: ", newdataNJSON);
                    console.log("Parsed logFC: ", logFC);

                    // Assuming logFC_json contains the JSON string
                     parsedLogFC_origin = JSON.parse(logFC);

                     parsedLogFC = parsedLogFC_origin
                    // Now, parsedLogFC is an array of objects
                    // Each object has properties "Gene" and "logFC"
                    console.log(parsedLogFC);

                    // You can access individual elements like this:
                    console.log(parsedLogFC[0].Gene); // Access the Gene property of the first object
                    console.log(parsedLogFC[0].logFC); // Access the logFC property of the first object

                    updateLogFCHistogram(parsedLogFC_origin)

                    // Store or manipulate the parsed data as needed
                })
                .catch(error => {
                    console.error("Error fetching filtered data: ", error);
                });
                  
              });
                // Handle failure of the RPC call
                req.fail(function(){
                          console.error("OpenCPU RPC call returned an error: " + req.responseText); 
                      });

                    })
              .catch(error => {
                  console.error("Error fetching dataC: ", error);
              });
            })
    });

    document.getElementById("log_thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      thr_fc = parseFloat(this.value);
      document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

      // Calculate the quantile
      log_thr_fc = Math.log2(thr_fc);  
      // Call the updateHistogram function directly
      updateLogFCHistogram(parsedLogFC_origin);
      console.log(logFC_data)
    });

    document.getElementById("log_thresholdSlider").addEventListener("change", function() {

      console.log("sono dentro")
      console.log("threshold "+thr_fc)
        // Find indices where abs(logFC) < log2(thr_fc)
        const ind = parsedLogFC.reduce((result, entry, index) => {
          
          if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            result.push(index);
            
          }
          return result;
        }, []);

        
      
        
        if (ind.length > 0) {

          console.log(parsedLogFC.length)
          console.log(newdataCJSON.length)
          console.log(newdataJSON.length)
          console.log(newdataNJSON.length)

          // Remove entries corresponding to ind from dataN
          newdataNJSON = newdataNJSON.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from dataC
          newdataCJSON = newdataCJSON.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from data
          newdataJSON = newdataJSON.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from genes
          //   genes = genes.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from logFC
          parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
          
          console.log(parsedLogFC.length)
          console.log(newdataCJSON.length)
          console.log(newdataJSON.length)
          console.log(newdataNJSON.length)

        }

        // Now, dataN, dataC, data, genes, and logFC are updated
    })


    function updateScatterPlot(fData) {
      // Clear previous scatter plot content
      d3.select("#scatterPlot").html("");

      // Set up the SVG container for the scatter plot
      const svgWidth = 900;
      const svgHeight = 400;
      const margin = { top: 20, right: 20, bottom: 30, left: 50 };
      const width = svgWidth - margin.left - margin.right;
      const height = svgHeight - margin.top - margin.bottom;

      const svg = d3.select("#scatterPlot")
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Debugging: Print fData to console
      console.log("fData:", fData);

      // Create scales for x and y axes
      const xScale = d3.scaleBand()
        .domain(fData.map(d => d.Gene))  // Gene names as x-axis labels
        .range([0, width])
        .padding(0.1);

      const yScale = d3.scaleLinear()
        .domain([0, d3.max(fData, d => d3.max(Object.values(d).slice(1)))])  // Max expression value across all samples
        .range([height, 0]);

      // Debugging: Print scales to console
      console.log("xScale:", xScale.domain());
      console.log("yScale:", yScale.domain());

      // Create circles for each data point
      svg.selectAll("circle")
        .data(fData)
        .enter()
        .append("circle")
        .attr("cx", d => {
          console.log("cx:", xScale(d.Gene) + xScale.bandwidth() / 2);
          return xScale(d.Gene) + xScale.bandwidth() / 2;  // Center within the band
        })
        .attr("cy", d => {
      console.log("cy:", yScale(d3.max(Object.values(d).slice(1))));
      return yScale(d3.max(Object.values(d).slice(1)));
        })
        .attr("r", 5)  // Set the radius of the circles
        .attr("fill", "steelblue");  // Set the color of the circles

      // Add x-axis
      svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end");

      // Add y-axis
      svg.append("g")
        .call(d3.axisLeft(yScale));
    }




    function updateHistogram() {
    // Load variation data using D3.js
    d3.text("variation_lung.txt").then(function (text) {
        // Parse the data
        const data = d3.tsvParseRows(text, d => ({ gene: d[0], variation: +d[1] }));

        // Filter data based on the threshold
        const filteredData = data.filter(d => d.variation >= thr_prc);

        // Create histogram using D3.js
        const svgWidth = 900;
        const svgHeight = 400;
        const margin = { top: 20, right: 20, bottom: 30, left: 50 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = d3.select("#IQR")
            .html("")  // Clear previous content
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create histogram
        const histogram = d3.histogram()
            .value(d => d.variation)
            .domain(d3.extent(data, d => d.variation))
            .thresholds(100);

        const bins = histogram(data);

        const xScale = d3.scaleLinear()
            .domain(d3.extent(data, d => d.variation))
            .range([0, width]);

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(bins, d => d.length)])
            .range([height, 0]);

        // Add histogram bars
        svg.selectAll("rect")
            .data(bins)
            .enter()
            .append("rect")
            .attr("x", d => xScale(d.x0))
            .attr("y", d => yScale(d.length))
            .attr("width", d => xScale(d.x1) - xScale(d.x0))
            .attr("height", d => height - yScale(d.length))
            .attr("fill", d => {
                const thresholdPosition = xScale(thr_prc);
                if (xScale(d.x1) < thresholdPosition) {
                    return "grey"; // Set the color to grey if d.x1 is less than the threshold
                } else {
                    return "steelblue"; // Set the original bar color
                }
            });

        // Add overlay for colored portion
        svg.selectAll(".overlay")
            .data(bins)
            .enter()
            .append("rect")
            .attr("class", "overlay")
            .attr("x", d => {
                const thresholdPosition = xScale(thr_prc);
                return xScale(d.x0); // Start the overlay from the beginning of the bar
            })
            .attr("y", d => yScale(d.length))
            .attr("width", d => {
                const thresholdPosition = xScale(thr_prc);
                const barWidth = xScale(d.x1) - xScale(d.x0);
                if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                    // Calculate the width of the portion to color
                    return thresholdPosition - xScale(d.x0); // Only color the left portion
                } else {
                    return 0; // Set width to 0 for bars where threshold is not in range
                }
            })
            .attr("height", d => height - yScale(d.length))
            .attr("fill", "grey") // Color the left portion of the overlay
            .attr("opacity", 1); // Set opacity for transparency

        // Add x-axis
        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(xScale));

        // Add y-axis
        svg.append("g")
            .call(d3.axisLeft(yScale));

        // Add a red line indicating the threshold
        const thresholdLine = svg.append("line")
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", "red")
            .attr("stroke-width", 2);

        // Update the position of the threshold line
        thresholdLine.attr("x1", xScale(thr_prc))
            .attr("x2", xScale(thr_prc));
        });
    }  
    // Initial histogram load
    updateHistogram();
  </script>
 





  

</body>
</html>

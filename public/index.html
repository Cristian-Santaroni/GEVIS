<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3.js Variation Histogram</title>
  <script src="d3.v7.8.5.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
  <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
  <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
  <script src="https://d3js.org/d3.v4.js"></script>
  
  <style>
    #thresholdSlider {
      width: 10%;
    }
  </style>
</head>
<body>
  
  <h2>IQR frequency distribution</h2>
  
  <div>
    <label for="thresholdSlider">InterQuantile range:</label>
    <input type="range" id="thresholdSlider" min="0.1" max="0.99" step="0.01" value="0.1">
    <span id="thresholdValue">0.1</span>
  </div>
  <div id="IQR">
  </div>
  <div id="geneCount"></div>


  <h2>LogFC Histogram</h2>
  <div>
    <label for="log_thresholdSlider">LogFC threshold:</label>
    <input type="range" id="log_thresholdSlider" min="1.1" max="10" step="0.01" value="1.1">
    <span id="log_thresholdSliderValue">1.1</span>
    <div id="logFCHistogram"></div>
  </div>
<div> 
  <button id="resetButton">Reset Zoom</button>
  <label for="thresholdSelect">Select Threshold:</label>
   <select id="thresholdSelect">
    <option value="0.05" selected>0.05</option>
  <option value="0.01">0.01</option>
   </select>
  <div id="scatterPlot"></div>  
  
</div>
  
  <div id="geneCount2"></div><br>
 
  <div id="parallelcoordinates"></div>
  
  <div id="boxPlot"></div>
  <div id="boxPlot1"></div>
  <div id="parallelCoordinates"></div>
  
  
 


  <script>
    ocpu.seturl("//localhost/ocpu/lib/GEVIS/R")
    let variation_data;
    let variation_data_copy;
    let initial_num_genes;
    let data_upd
    let prc_IQR = 0.1;
    let thr_prc;
    let filteredData;
    let matrix;
    let data_original;
    let dataC_original;
    let dataN_original;
    let data_copy;
    let dataC_copy;
    let dataN_copy;
    let data_copy1;
    let dataC_copy1;
    let dataN_copy1;
    let thr_fc = 1.1;
    let logFC_data;
    let log_thr_fc = Math.log2(thr_fc);
    let parsedLogFC;
    let parsedLogFC_origin;
    let parsedLogFC_origin1;
    let newdataJSON
    let newdataCJSON
    let first_filter_number_genes;
    let p_val_adj;
    let threshold= 0.05;
    let averageExpressions10C;
    let averageExpressions10N;
    let averageExpressionsC;
    let averageExpressionsN;
    let selectedGeneData=[];
    let old_p_adj

    var scatter;

    function calculateLogFC(dataC, dataN) {
    const logFCData = [];

    // Iterate over each gene
    Object.keys(dataC).forEach(gene => {
        // Get the values for the current gene from dataC and dataN
        let valuesC = Object.values(dataC[gene]);
        let valuesN = Object.values(dataN[gene]);

        // Pop the last value if it's a gene string
        let geneValueC;
        if (isNaN(valuesC[valuesC.length - 1])) {
            geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
        }
        let geneValueN;
        if (isNaN(valuesN[valuesN.length - 1])) {
            geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
        }

        // Calculate the row mean for dataC and dataN
        const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
        const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

        // Calculate the log fold change
        const logFC = rowMeanC - rowMeanN;

        // Push the gene and its logFC to logFCData
        logFCData.push({ "Gene": geneValueC, "logFC": logFC });
    });

    return logFCData

}


    function fetchJSON(url) {
      return fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          // Rename the key '_row' to 'Gene' in each object of the JSON array
          return data.map(obj => {
            const newObj = { ...obj };
            newObj['gene'] = newObj['_row'];
            delete newObj['_row']; // Delete the old key
            return newObj;
          });
        })
        .catch(error => {
          console.error('Error fetching JSON:', error);
        });
    }

    // Define a function to fetch data from a file with no header
    function fetchData(filename) {
    return fetch(filename)
    .then(response => response.text())
    .then(text => {
        // Parse the data
        const rows = text.trim().split('\n');
        
        // Extract sample GSM identifiers from the first row (excluding the first element)
        const sampleGSMs = rows[0].trim().split('\t').slice(1);

        // Map each row to an object representing gene expression for each sample
        matrix = rows.slice(1).map(row => {
            const [gene, ...expressions] = row.trim().split('\t');
            
            // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
            return {
                gene: gene,
                expressions: expressions.map(parseFloat)
            };
        });

        // Create a matrix with GSMs as headers
        const matrixWithHeaders = matrix.reduce((result, entry) => {
            const geneObj = {
                Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
            };
            result.push(geneObj);
            return result;
        }, []);
        return matrixWithHeaders; // Return the matrix with headers
    });
  }

    // Read the contents of the .txt file
    Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json')])
      .then(([dataC, dataN, data]) => {
        dataC_original = dataC
        dataN_original = dataN
        data_original = data
        fetch('variation_lung.txt')
          .then(response => response.text())
          .then(text => {
            // Parse the data
            const rows = text.split('\n');
            variation_data = rows.slice(1).map(row => {
              const [gene, variation] = row.trim().split('\t');
              return parseFloat(variation);
            });
            const row_length= rows.length-1
            initial_num_genes = row_length
            variation_data_copy = (variation_data);
            console.log("numero di geni iniziali prima di qualsiasi filtro "+row_length)

            thr_prc = ss.quantile(variation_data, prc_IQR);
            updateHistogram(variation_data);

            const ind = variation_data_copy.reduce((result, entry, index) => {
              
              if (entry < thr_prc) {
                result.push(index);
              }
              return result;
            }, []);

            if (ind.length > 0) {

              // Remove entries corresponding to ind from dataN
              data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from dataC
              dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from data
              dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from genes
              //genes = genes.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from logFC
              //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            }
            dataN_copy=dataN_copy1
            dataC_copy=dataC_copy1
            data_copy=data_copy1


            // Update the gene count display
            const geneCountDiv = document.getElementById('geneCount');
            geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

            first_filter_number_genes = data_copy.length

            parsedLogFC_origin1= calculateLogFC(dataC_original,dataN_original)
            parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
            parsedLogFC = parsedLogFC_origin

            //  console.log("first parsed origin after",parsedLogFC_origin.length)
            //  console.log("first data orign afterN ",dataN_copy.length)
            //  console.log("first data orign afterC ",dataC_copy.length)
          
             averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
             averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);


             fetch('genes_and_pval_adj.json')
                .then(response => response.json())
                .then(data => {
                  p_val_adj=data
               
            
            
            updateLogFCHistogram(parsedLogFC_origin)
            
              var req = ocpu.call("hello", {
              data: data_copy
          }, function(session) {
              var filteredDataURL = session.loc + "/R/.val/json";
              console.log(session);
              // Fetch the filtered data from the URL
              fetch(filteredDataURL)
                  .then(response => response.json())
                  .then(data => {
                    old_p_adj=data
                    const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);

        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc,parsedLogFC_origin1,old_p_adj)
            updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
            updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)
            updateParallel(parsedLogFC,data_copy,dataC_copy,dataN_copy)
                              }

      });
    })

            
                  // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);           

          })
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

          const geneCountDiv2 = document.getElementById('geneCount2');
          geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


          })
          .catch(error => console.error('Error reading file:', error));
        });

    document.getElementById("thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      prc_IQR = parseFloat(this.value);
      document.getElementById("thresholdValue").innerText = prc_IQR;

      // Calculate the quantile
      thr_prc = ss.quantile(variation_data_copy, prc_IQR);
      updateHistogram(variation_data);

      const ind = variation_data_copy.reduce((result, entry, index) => {
        
        if (entry <= thr_prc) {
          result.push(index);
        }
        return result;
      }, []);


      if (ind.length > 0) {
        // Remove entries corresponding to ind from dataC
        dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from data
        dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

        data_copy1  = data_original.filter((entry, index) => !ind.includes(index));
        
        // Remove entries corresponding to ind from genes
        //genes = genes.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from logFC
        //parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

      }
      // Update the gene count display
      const geneCountDiv = document.getElementById('geneCount');
      geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${dataC_copy1.length}`;

      first_filter_number_genes = dataC_copy.length

      parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
      parsedLogFC = parsedLogFC_origin

      
      updateLogFCHistogram(parsedLogFC_origin)

  
      console.log(parsedLogFC_origin)

      log_thr_fc = Math.log2(thr_fc);  
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

      const geneCountDiv2 = document.getElementById('geneCount2');
      geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length - ind2.length}`;

    });

    document.getElementById("thresholdSlider").addEventListener("change", function() {

      const ind = variation_data_copy.reduce((result, entry, index) => {
        
        if (entry <= thr_prc) {
          result.push(index);
        }
        return result;
      }, []);

      if (ind.length > 0) {

        // Remove entries corresponding to ind from dataN
       // data_copy = data_original.filter((entry, index) => !ind.includes(index));

       // dataC_copy = dataC_original.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from data
        //dataN_copy = dataN_original.filter((entry, index) => !ind.includes(index));
        // Remove entries corresponding to ind from genes
        //genes = genes.filter((entry, index) => !ind.includes(index));

      }
      // Update the gene count display
      const geneCountDiv = document.getElementById('geneCount');
      geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

      first_filter_number_genes = data_copy.length

      log_thr_fc = Math.log2(thr_fc);  
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

      const geneCountDiv2 = document.getElementById('geneCount2');
      geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;



    });

    document.getElementById("log_thresholdSlider").addEventListener("input", function() {
        // Update the threshold value on slider change
        thr_fc = parseFloat(this.value);
        document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

        // Calculate the quantile
        log_thr_fc = Math.log2(thr_fc);  
        console.log(log_thr_fc)
        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
            
            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
              result.push(index);
              
            }
            return result;
          }, []);

          // console.log("parsed log before ",parsedLogFC.length)
          // console.log("data copy beforeC ",dataC_copy.length)
          // console.log("data copy beforeN ",dataN_copy.length)

          // console.log("parsed log origin ",parsedLogFC_origin.length)
          /////////////////////// 
          
          //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

          //////////////////////

          if (ind.length>0){

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index)); 
          }

          /////////////////////// 

          //DIMENSIONE DI PARSED E DATAC,DATAN SONO DIVERSE , QUESTA COSA E' GIUSTA?

          //////////////////////
          // console.log("parsed log after",parsedLogFC.length)
          // console.log("data copy afterC ",dataC_copy.length)
          // console.log("data copy afterN",dataN_copy.length)
          // console.log("parsedLogFCorig ",parsedLogFC_origin.length)


        const geneCountDiv = document.getElementById('geneCount2');
        geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

        // Call the updateHistogram function directly
        updateLogFCHistogram(parsedLogFC_origin);
        //console.log(log_thr_fc)
      });

    document.getElementById("log_thresholdSlider").addEventListener("change", function() {

   
        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
          
          if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            result.push(index);
            
          }
          return result;
        }, []);
        
        //console.log("parsed log ",parsedLogFC.length)
        //console.log("data copy beforeC ",dataC_copy.length)
        //console.log("data copy beforeN",dataN_copy.length)
        
        
        if (ind.length > 0) {

          // Remove entries corresponding to ind from dataN

          // // Remove entries corresponding to ind from dataN
          // dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

          // // Remove entries corresponding to ind from dataN
          // dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));

          // data_copy = data_copy.filter((entry, index) => !ind.includes(index));

          
          // // Remove entries corresponding to ind from logFC
          // parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
          
          //console.log(parsedLogFC.length)

        }


        var req = ocpu.call("hello", {
              data: data_copy
          }, function(session) {
              var filteredDataURL = session.loc + "/R/.val/json";
              console.log(session);
              // Fetch the filtered data from the URL
              fetch(filteredDataURL)
                  .then(response => response.json())
                  .then(data => {
                    old_p_adj=data
                    const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);

        // if (ind.length > 0) {
        //     //console.log(parsedLogFC.length)

        //     // Remove entries corresponding to ind from dataN

        //     // Remove entries corresponding to ind from dataN
        //     dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

        //     // Remove entries corresponding to ind from dataN
        //     dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


        //     data_copy = data_copy.filter((entry, index) => !ind.includes(index));

        //     // Remove entries corresponding to ind from logFC
        //     parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
            
            
        //     updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
        //     updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)
        //     updateParallel(parsedLogFC,data_copy,dataC_copy,dataN_copy)
            
        //   }

      });
    })


        updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc,parsedLogFC_origin1,old_p_adj)
        //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
        // console.log("parsed log ",parsedLogFC.length)
        // console.log("data copy beforeC ",dataC_copy.length)
        // console.log("data copy beforeN",dataN_copy.length)

        const geneCountDiv = document.getElementById('geneCount2');
        geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;
        
        // Now, dataN, dataC, data, genes, and logFC are updated
    })

    // Assuming newdataNJSON, newdataCJSON, and newdataJSON are your arrays of data
    document.getElementById('thresholdSelect').addEventListener('change', function () {
    //console.log(dataC_copy)
    //console.log(data_copy)
    //console.log(dataN_copy)
    
        threshold = parseFloat(this.value);

          const ind = old_p_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > threshold) {
            result.push(index);
          }
          return result;
        }, []);

        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            
            updateBoxPlot(parsedLogFC,dataN_copy,dataC_copy)
            updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)
            updateParallel(parsedLogFC,data_copy,dataC_copy,dataN_copy) 
                              }

      })
    
  

//});

    function updateHistogram(variation_data) {
    // Filter data based on the threshold
    const filteredData = variation_data.filter(variation => variation >= thr_prc);

    // Create histogram using D3.js
    const svgWidth = 900;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 30, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    const svg = d3.select("#IQR")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram
    const histogram = d3.histogram()
        .value(variation => variation)
        .domain(d3.extent(variation_data))
        .thresholds(100);

    const bins = histogram(variation_data);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(variation_data))
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", d => {
            const thresholdPosition = xScale(thr_prc);
            if (xScale(d.x1) < thresholdPosition) {
                return "grey"; // Set the color to grey if d.x1 is less than the threshold
            } else {
                return "steelblue"; // Set the original bar color
            }
        });

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(thr_prc);
            return xScale(d.x0); // Start the overlay from the beginning of the bar
        })
        .attr("y", d => yScale(d.length))
        .attr("width", d => {
            const thresholdPosition = xScale(thr_prc);
            const barWidth = xScale(d.x1) - xScale(d.x0);
            if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                // Calculate the width of the portion to color
                return thresholdPosition - xScale(d.x0); // Only color the left portion
            } else {
                return 0; // Set width to 0 for bars where threshold is not in range
            }
        })
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "grey") // Color the left portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale));

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale));

    // Add a red line indicating the threshold
    const thresholdLine = svg.append("line")
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "red")
        .attr("stroke-width", 2);

    // Update the position of the threshold line
    thresholdLine.attr("x1", xScale(thr_prc))
        .attr("x2", xScale(thr_prc));
}
    
    function updateLogFCHistogram(logFCData) {
    // Extract logFC values and convert them to numbers
    const logFCValues = logFCData.map(entry => entry.logFC);

    // Define histogram parameters
    const svgWidth = 900;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 50, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    // Create SVG container
    const svg = d3.select("#logFCHistogram")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram using D3.js
    const histogram = d3.histogram()
        .value(d => d)
        .domain(d3.extent(logFCValues))
        .thresholds(100); // Number of bins

    const bins = histogram(logFCValues);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(logFCValues))
        .nice()
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .nice()
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "orange");

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .append("text")
        .attr("x", width / 2)
        .attr("y", margin.bottom * 0.8)
        .attr("text-anchor", "middle")
        .text("logFC");

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale))
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left * 0.7)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .text("frequency");

    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", -margin.top * 0.7)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .text("FC (logarithmic) frequency distribution");

    // Add ablines
    svg.append("line")
        .attr("x1", xScale(-Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(-Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    svg.append("line")
        .attr("x1", xScale(Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
            return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
        })
        .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
        .attr("width", d => {
            const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
            const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
            const barWidth = xScale(d.x1) - xScale(d.x0);
            // Calculate the width of the portion to color
            return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
        })
        .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
        .attr("fill", "grey") // Color the portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency

}

    function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

      console.log(parsed)

      var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
      return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
       }, parsed[0]);

       var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
      return currentGene.logFC < minGene.logFC ? currentGene : minGene;
       }, parsed[0]);

       console.log(mostUpregulatedGene)
       var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
       var mostDownregulatedGeneName = mostDownregulatedGene.Gene;



            // Set up margin, width, and height
        var margin = { top: 10, right: 120, bottom: 60, left: 60 };
        var width = 800 - margin.left - margin.right;
        var height = 500 - margin.top - margin.bottom;

        // Create SVG container
        var svg = d3.select("#scatterPlot")
            .html("")  // Clear previous content
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
              
        // Create x and y scales
        var xScale = d3.scaleLinear()
            .domain(d3.extent(Object.values(averageExpressionsN)))
            .range([0, width]);

        var yScale = d3.scaleLinear()
            .domain(d3.extent(Object.values(averageExpressionsC)))
            .range([height, 0])
            .nice()

            

        // Add X axis
        var xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale).tickSize(-height*1.3).ticks(10))

        // Add Y axis
        var yAxis = svg.append("g")
            .call(d3.axisLeft(yScale).tickSize(-width*1.3).ticks(7))
    
        // Customization
        svg.selectAll(".tick line").attr("stroke", "#EBEBEB")
        var clip = svg.append("defs").append("SVG:clipPath")
            .attr("id", "clip")
            .append("SVG:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

        // Create the scatter variable: where both the circles and the brush take place
         scatter = svg.append('g')
            .attr("clip-path", "url(#clip)");

        // Set the zoom and Pan features
        var zoom = d3.zoom()
            .scaleExtent([0.5, 20])
            .extent([[0, 0], [width, height]])
            .on("zoom", updateChart);

        // Add an invisible rect on top of the chart area
        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
            .style("pointer-events", "all")  // Set pointer-events to "all" here
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .lower();

        // Attach zoom behavior to the SVG
        svg.call(zoom);

        // Attach click event to the reset button
        d3.select("#resetButton")
            .on("click", resetZoom);


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Expression (Normal)");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Expression (Case)");

            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top )
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatterplot");

            // // Add X axis
            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(xScale));

            // // Add Y axis
            // svg.append("g")
            //     .call(d3.axisLeft(yScale));

            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if( logFC <= log_thr_fc ){
                  var type = "down"
                }
                else{
                  var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width + 2) + "," + 20 + ")");

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 10)
                .attr("r", 3)
                .style("fill", "red");

            legend.append("text")
                .attr("x", 20)
                .attr("y", 10)
                .text("Upregulated");

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 30)
                .attr("r", 3)
                .style("fill", "blue");

            legend.append("text")
                .attr("x", 20)
                .attr("y", 30)
                .text("Downregulated");

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 50)
                .attr("r", 3)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 20)
                .attr("y", 50)
                .text("Not Significant");

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => xScale(d.Normal))
                .attr("cy", d => yScale(d.Case))
                .attr("r", d=>{
                  if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName ) {
                        return "2";
                  }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if(d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if(d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName){
                            return "4"
                    }
                    else if(d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName){
                          return "4"
                    }
                })
                .style("fill", d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                        return "red";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        return "blue";
                    } else  {
                        return "grey";
                    }
                    
                })
                .on("mouseover", function (d) {
                  // Highlight the gene on mouseover
                  d3.select(this)
                      .style("stroke", "black")
                      .style("stroke-width", 2);
                    
                  // Display tooltip on mouseover
                  tooltip.transition()
                      .style("opacity", .9);

                  tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toFixed(2) : 'NA'}`)
                      .style("left", (d3.event.pageX + 15) + "px")
                      .style("top", (d3.event.pageY - 28) + "px");
              })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .style("opacity", 0);
                })
                .on("click", function (d) {
                  var selectedElement = d3.select(this);
                  
                  // Check if the element is already highlighted
                  var isHighlighted = selectedElement.style("fill") === "green";

                  if (isHighlighted) {
                    console.log("sono verde")
                      // If already highlighted, remove the highlighting
                      selectedElement.style("fill",d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                        return "red";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        return "blue";
                    } else  {
                        return "grey";
                    }

                  });
                  for (let i = 0; i < selectedGeneData.length; i++) {
                    selectedGeneData[i] = selectedGeneData[i].filter(gene => gene.gene !== d.gene);
                  }
                createParallelCoordinates(selectedGeneData);
                  } else {
                      // If not highlighted, apply the highlighting
                      selectedElement
                          .style("fill", "green")
                          .style("stroke-width", 2);

                      // On click, filter data for the selected gene
                      selectedGeneData.push(data.filter(gene => gene.gene === d.gene));
                      console.log(selectedGeneData);

                      // Call a function to create parallel coordinates plot using selectedGeneData
                      createParallelCoordinates(selectedGeneData);
                  }
                });

            function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(xScale);
            var newY = d3.event.transform.rescaleY(yScale);
            
            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX).tickSize(-height * 1.3).ticks(10));
            yAxis.call(d3.axisLeft(newY).tickSize(-width * 1.3).ticks(7));
            svg.selectAll(".tick line").attr("stroke", "#EBEBEB")
            // update circle position
            scatter
                .selectAll("circle")
                .attr('cx', function (d) { return newX(d.Normal); })
                .attr('cy', function (d) { return newY(d.Case); });
        }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                  .duration(750)
                  .call(zoom.transform, d3.zoomIdentity);
              }



       
        


        
}

    function createParallelCoordinates(selectedGeneData) {
     // var dataArray = Object.values(selectedGeneData);
      //console.log(dataArray[0]);
      console.log([selectedGeneData]);

        var margin = {top: 30, right: 50, bottom: 10, left: 50},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
          var svg = d3.select("#parallelcoordinates")
          .html("")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");


                  dimensions = ["Normal", "Case","logFC","pval_adj"]
          
        var color=d3.scaleOrdinal().domain(["up","down"]).range(["red","blue"])


          var highlight = function(d){

            selected_reg= d.type

            // first every group turns grey
            d3.selectAll(".line")
            .transition().duration(200)
            .style("stroke", "lightgrey")
            .style("opacity", "0.2")

            // Second the hovered specie takes its color
            d3.selectAll("." + selected_reg)
            .transition().duration(200)
            .style("stroke", color(selected_reg))
            .style("opacity", "1")

          }

            // Unhighlight
          var doNotHighlight = function(d){
            d3.selectAll(".line")
              .transition().duration(200).delay(1000)
              .style("stroke", function(d){ return( color(d.type))} )
              .style("opacity", "1")
          }

        var y = {}
        for (i in dimensions) {
          name = dimensions[i]
          y[name] = d3.scaleLinear()
            .domain( [-8,8] ) // --> Same axis range for each group
            // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
            .range([height, 0])
        }
          // Build the X scale -> it find the best position for each Y axis
        var x = d3.scalePoint()
          .range([0, width])
          .domain(dimensions)


          function path(d) {
            console.log(d)
            return d3.line()(dimensions.map(function(p,i) { 
              return [  x(p), y[p](d[p])   ];}));
        }

        if(selectedGeneData && selectedGeneData.length > 0){
          console.log(selectedGeneData.length)
        selectedGeneData.forEach(element => {
          svg
        .selectAll("myPath")
        .data(element) // Use the entire array directly
        .enter()
        .append("path")
        .attr("class", function (d) { return "line " + d.type } )
        .style("fill", "none" )
        .style("stroke", function(d){ return( color(d.type))} )
        .style("opacity", 0.5)
        .on("mouseover", highlight)
        .on("mouseleave", doNotHighlight )
        .attr("d", path)
        .on("click", onLineClick); // Add click event to new lines
    });
  }

  


        // Draw the axis:
        svg.selectAll("myAxis")
          // For each dimension of the dataset I add a 'g' element:
          .data(dimensions).enter()
          .append("g")
          .attr("class", "axis")
          // I translate this element to its right position on the x axis
          .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
          // And I build the axis with the call function
          .each(function(d) { d3.select(this).call(d3.axisLeft().ticks(5).scale(y[d])); })
          // Add axis title
          .append("text")
            .style("text-anchor", "middle")
            .attr("y", -9)
            .text(function(d) { return d; })
            .style("fill", "black")

        function onLineClick(d) {
        // Remove the clicked gene from selectedGeneData
        //selectedGeneData = selectedGeneData.filter(gene => gene.gene !== d.gene);
        for (let i = 0; i < selectedGeneData.length; i++) {
          selectedGeneData[i] = selectedGeneData[i].filter(gene => gene.gene !== d.gene);
      }
      //console.log(selectedGeneData)
        // Remove the line from the parallel coordinates plot
        svg.selectAll(".line." + d.type)
            .remove();

        // Remove highlighting color in the scatter plot
         scatter.selectAll("circle")
             .filter(circleData => circleData.gene === d.gene)
             .style("fill", d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold ) {
                        return "red";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        return "blue";
                    } else  {
                        return "grey";
                    }
                  });
                  

        // Update parallel coordinates plot
        createParallelCoordinates(selectedGeneData);
    }

        
      }

    function updateBoxPlot(parsedLogFC,dataN,dataC){
        var mostUpregulatedGene = parsedLogFC.reduce((maxGene, currentGene) => {
      return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
       }, parsedLogFC[0]);

    //console.log(mostUpregulatedGene)
    var geneName = mostUpregulatedGene.Gene;
    
    // console.log(dataN)  
    // console.log(dataC)
    // console.log(parsedLogFC)


    //console.log(mostUpregulatedGene)

    var geneDataN = dataN.filter(d => d.gene === geneName)
    var geneDataC = dataC.filter(d => d.gene === geneName)

   //console.log()

    

        function computeBoxPlotStatistics(data1) {
          var expressionValues = data1.map(entry => entry.expression);

          // Sort the data for calculating quartiles
          expressionValues.sort((a, b) => a - b);

          // Calculate quartiles and median
          var q1 = d3.quantile(expressionValues, 0.25);
          var q3 = d3.quantile(expressionValues, 0.75);
          var median = d3.median(expressionValues);

          // Calculate interquartile range (IQR)
          var iqr = q3 - q1;


          var min = q1 - 1.5 * iqr
          var max = q3 + 1.5 * iqr

        return {
            q1: q1,
            median: median,
            q3: q3,
            iqr: iqr,
            min: min,
            max: max
        };
    }
    
    let expressionValuesC
      geneDataC.forEach(entry => {
          expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })

        //console.log(expressionValuesC)
          
      let expressionValuesN
      geneDataN.forEach(entry => {
          expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
// Assuming you have expressionValuesC and expressionValuesN

    // Create a new array to store the combined data
    var combinedData = [];

    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
    expressionValuesC.forEach(expression => {
        combinedData.push({ expression: expression, type: 'case' });
    });

    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
    expressionValuesN.forEach(expression => {
        combinedData.push({ expression: expression, type: 'normal' });
    });

    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


    var sumstat = d3.nest()
    .key(function(d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
    .rollup(function(d) {
        q1 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.25);
        median = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.5);
        q3 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.75);
        interQuantileRange = q3 - q1;
        min = q1 - 1.5 * interQuantileRange;
        max = q3 + 1.5 * interQuantileRange;

        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
    })
    .entries(combinedData);

    
    

    var margin = {top: 10, right: 30, bottom: 30, left: 40},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;


    var svg = d3.select("#boxPlot")
    .html("")  // Clear previous content
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
   
    var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(["normal", "case"])
    .paddingInner(1)
    .paddingOuter(.5)
    
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

    var y = d3.scaleLinear()
    .domain([0,boxPlotStatisticsC.max])
    .range([height, 0])
   svg.append("g").call(d3.axisLeft(y))


   // Add a title
svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top)
    .attr("text-anchor", "middle")
    .style("font-size", "18px")
    .text("The Most Upregulated Gene "+ geneName);

   svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 100
  svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "#69b3a2")
    svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.median))})
      .attr("y2", function(d){return(y(d.value.median))})
      .attr("stroke", "black")
      .style("width", 80)

      var jitterWidth = 50
    svg
      .selectAll("indPoints")
      .data(combinedData)
      .enter()
      .append("circle")
        .attr("cx", function(d){return(x(d.type) - jitterWidth/2 + Math.random()*jitterWidth )})
        .attr("cy", function(d){return(y(d.expression))})
        .attr("r", 2)
        .style("fill", "white")
        .attr("stroke", "black")



  }

    function updateBoxPlot1(parsedLogFC,dataN,dataC){
    var mostDownregulatedGene = parsedLogFC.reduce((minGene, currentGene) => {
      return currentGene.logFC < minGene.logFC ? currentGene : minGene;
       }, parsedLogFC[0]);

    //console.log(mostUpregulatedGene)
    var geneName = mostDownregulatedGene.Gene;
    
    

    var geneDataN = dataN.filter(d => d.gene === geneName)
    var geneDataC = dataC.filter(d => d.gene === geneName)

    

     console.log(geneDataC)  
     console.log(geneDataC)

        function computeBoxPlotStatistics(data1) {
          var expressionValues = data1.map(entry => entry.expression);

          // Sort the data for calculating quartiles
          expressionValues.sort((a, b) => a - b);

          // Calculate quartiles and median
          var q1 = d3.quantile(expressionValues, 0.25);
          var q3 = d3.quantile(expressionValues, 0.75);
          var median = d3.median(expressionValues);

          // Calculate interquartile range (IQR)
          var iqr = q3 - q1;


          var min = q1 - 1.5 * iqr
          var max = q3 + 1.5 * iqr

        return {
            q1: q1,
            median: median,
            q3: q3,
            iqr: iqr,
            min: min,
            max: max
        };
    }
    let expressionValuesC
      geneDataC.forEach(entry => {
          expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
    let expressionValuesN
      geneDataN.forEach(entry => {
          expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
// Assuming you have expressionValuesC and expressionValuesN

    // Create a new array to store the combined data
    var combinedData = [];

    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
    expressionValuesC.forEach(expression => {
        combinedData.push({ expression: expression, type: 'case' });
    });

    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
    expressionValuesN.forEach(expression => {
        combinedData.push({ expression: expression, type: 'normal' });
    });

// Now combinedData has the desired structure
    console.log(combinedData);

   

    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


    var sumstat = d3.nest()
    .key(function(d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
    .rollup(function(d) {
        q1 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.25);
        median = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.5);
        q3 = d3.quantile(d.map(function(g) { return g.expression; }).sort(d3.ascending), 0.75);
        interQuantileRange = q3 - q1;
        min = q1 - 1.5 * interQuantileRange;
        max = q3 + 1.5 * interQuantileRange;

        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
    })
    .entries(combinedData);

    console.log("Q1:", boxPlotStatisticsC.q1);
    console.log("Q3:", boxPlotStatisticsC.q3);
    console.log("Median:", boxPlotStatisticsC.median);
    console.log("IQR:", boxPlotStatisticsC.iqr);
    /*geneDataN.forEach(entry => {
    // Extract the numeric expression values
    var expressionValues = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

    
    // Find the maximum expression value for each gene
    entry.expression = d3.max(expressionValues);

    // Update ymin and ymax based on the current gene's expression value
    ymin = Math.min(ymin, entry.expression);
    ymax = Math.max(ymax, entry.expression);

    });
    */
    
    console.log(boxPlotStatisticsC)
    
  
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;


    var svg = d3.select("#boxPlot1")
      .html("")  // Clear previous content
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
   
    var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(["normal", "case"])
    .paddingInner(1)
    .paddingOuter(.5)
    
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

    var y = d3.scaleLinear()
    .domain([0,boxPlotStatisticsC.max])
    .range([height, 0])
   svg.append("g").call(d3.axisLeft(y))

    // Add a title
svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top)
    .attr("text-anchor", "middle")
    .style("font-size", "18px")
    .text("The Most Downregulated Gene " + geneName);


   svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 100
  svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "#69b3a2")

    svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.median))})
      .attr("y2", function(d){return(y(d.value.median))})
      .attr("stroke", "black")
      .style("width", 80)

    var jitterWidth = 50
    svg
      .selectAll("indPoints")
      .data(combinedData)
      .enter()
      .append("circle")
        .attr("cx", function(d){return(x(d.type) - jitterWidth/2 + Math.random()*jitterWidth )})
        .attr("cy", function(d){return(y(d.expression))})
        .attr("r", 2)
        .style("fill", "white")
        .attr("stroke", "black")
  }
    
    function updateParallel(parsedLogFc,data,dataC,dataN){
      //console.log (parsedLogFC)
      // var mostUpregulatedGene = parsedLogFC.reduce((maxGene, currentGene) => {
      // return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
      //  }, parsedLogFC[0]);

      //  var mostDownregulatedGene = parsedLogFC.reduce((minGene, currentGene) => {
      // return currentGene.logFC < minGene.logFC ? currentGene : minGene;
      //  }, parsedLogFC[0]);


       var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

      var mostUpregulatedGene = sortedLogFC[0];
      var secondMostUpregulatedGene = sortedLogFC[1];

      var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
      var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

      var mostUpregulatedGeneName = mostUpregulatedGene.Gene
      //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
      var mostDownregulatedGeneName = mostDownregulatedGene.Gene
      //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


      var geneDataNUp = dataN.filter(d => d.gene === mostUpregulatedGeneName)
      var geneDataCUp = dataC.filter(d => d.gene === mostUpregulatedGeneName)
      
      var geneDataNDown = dataN.filter(d => d.gene === mostDownregulatedGeneName)
      var geneDataCDown = dataC.filter(d => d.gene === mostDownregulatedGeneName)


      // console.log (geneDataNUp)
      // console.log (geneDataCUp)

      // console.log (geneDataNDown)
      // console.log (geneDataCDown)

          

      let expressionValuesCUp
      geneDataCUp.forEach(entry => {
          expressionValuesCUp = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
      let expressionValuesNUp
        geneDataNUp.forEach(entry => {
            expressionValuesNUp = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

          })

      let expressionValuesCDown
      geneDataCDown.forEach(entry => {
          expressionValuesCDown = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

        })
      let expressionValuesNDown
        geneDataNDown.forEach(entry => {
            expressionValuesNDown = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

          })

            


      var combinedDataUp = [];

          // Iterate over expressionValuesC and add objects to combinedData with type 'case'
          expressionValuesCUp.forEach(expression => {
              combinedDataUp.push({ expression: expression, type: 'case' });
          });

          // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
          expressionValuesNUp.forEach(expression => {
              combinedDataUp.push({ expression: expression, type: 'normal' });
          });



          var combinedDataDown = [];

              // Iterate over expressionValuesC and add objects to combinedData with type 'case'
              expressionValuesCDown.forEach(expression => {
                  combinedDataDown.push({ expression: expression, type: 'case' });
              });

              // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
              expressionValuesNDown.forEach(expression => {
                  combinedDataDown.push({ expression: expression, type: 'normal' });
              });



              var structureCombinedData = {
                        mostUpregulated: {
                          gene: mostUpregulatedGeneName,
                            expressions: combinedDataUp.map(entry => entry.expression),
                            type: combinedDataUp.map(entry => entry.type)
                        },
                        mostDownregulated: {
                            gene: mostDownregulatedGeneName,
                            expressions: combinedDataDown.map(entry => entry.expression),
                            type: combinedDataDown.map(entry => entry.type)
                        }
                    };
                    
  console.log(structureCombinedData);
          

  // set the dimensions and margins of the graph
        var margin = {top: 30, right: 50, bottom: 10, left: 50},
          width = 460 - margin.left - margin.right,
          height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#parallelCoordinates")
        .html("")  // Clear previous content
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

          var color = d3.scaleOrdinal()
              .domain(["case","normal" ])
              .range([ "blue", "red"])

          dimensions = [mostUpregulatedGeneName, mostDownregulatedGeneName]

          var y = {}
            for (i in dimensions) {
              name = dimensions[i]
              y[name] = d3.scaleLinear()
                .domain( [0,20] ) 
                .range([height, 0])
            }
            // Build the X scale -> it find the best position for each Y axis
            x = d3.scalePoint()
              .range([0, width])
              .domain(dimensions);
              

              function path(d) {
              // Extract gene, expressions, and type from the structure
              var expressionsUp = d.mostUpregulated.expressions;
              var expressionsDown = d.mostDownregulated.expressions;

              // Return x and y coordinates using dimensions, x, and y functions
              return d3.line()([
                [x(mostUpregulatedGeneName), y[mostUpregulatedGeneName](expressionsUp)],
                [x(mostDownregulatedGeneName), y[mostDownregulatedGeneName](expressionsDown)]
              ]);
            }


            var lineTypes = structureCombinedData.mostUpregulated.type;

            svg
              .selectAll("myPath")
              .data(structureCombinedData.mostUpregulated.expressions) // Assuming both genes have the same number of expressions
              .enter()
              .append("path")
              .attr("d", function (_, i) {
                // For each iteration, create a line connecting the expressions of both genes at the same index
                var dataPoint = {
                  mostUpregulated: {
                    gene: structureCombinedData.mostUpregulated.gene,
                    expressions: structureCombinedData.mostUpregulated.expressions[i],
                  },
                  mostDownregulated: {
                    gene: structureCombinedData.mostDownregulated.gene,
                    expressions: structureCombinedData.mostDownregulated.expressions[i],
                  }
                };
                return path(dataPoint);
              })
              .style("fill", "none")
              .style("stroke", function (_, i) { return color(lineTypes[i]); })
              .style("opacity", 0.5);
            
        // Draw the axis:
        svg.selectAll("myAxis")
          // For each dimension of the dataset I add a 'g' element:
          .data(dimensions).enter()
          .append("g")
          // I translate this element to its right position on the x axis
          .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
          // And I build the axis with the call function
          .each(function(d) { d3.select(this).call(d3.axisLeft().scale(y[d])); })
          // Add axis title
          .append("text")
            .style("text-anchor", "middle")
            .attr("y", -9)
            .text(function(d) { return d; })
            .style("fill", "black")
  
}

    function calculateAverageExpressions(dataArray) {
      // Create an object to store the sum and count for each gene
      var geneSumCount = {};

      // Iterate through each gene object in the array
      dataArray.forEach(function (geneData) {
          var gene = geneData.gene;

          // Iterate through each property (sample) in the gene object
          for (var sample in geneData) {
              if (sample !== 'gene') {
                  // If the gene is not in the sumCount object, initialize it
                  if (!geneSumCount[gene]) {
                      geneSumCount[gene] = { sum: 0, count: 0 };
                  }

                  // Add the expression value to the sum and increment the count
                  geneSumCount[gene].sum += parseFloat(geneData[sample]);
                  geneSumCount[gene].count++;
              }
          }
      });

      // Calculate the average for each gene
      var averageExpressions = {};
      for (var gene in geneSumCount) {
          averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
      }

      return averageExpressions;
  }

    function calculateAverageLog10Expressions(dataArray) {
    // Create an object to store the sum and count for each gene
    var geneSumCount = {};

    // Iterate through each gene object in the array
    dataArray.forEach(function (geneData) {
        var gene = geneData.gene;

        // Iterate through each property (sample) in the gene object
        for (var sample in geneData) {
            if (sample !== 'gene') {
                // If the gene is not in the sumCount object, initialize it
                if (!geneSumCount[gene]) {
                    geneSumCount[gene] = { sum: 0, count: 0 };
                }

                // Apply Math.log10 to the expression value before summing
                var log10Expression = Math.log2(parseFloat(geneData[sample]));

                // Add the log10 expression value to the sum and increment the count
                geneSumCount[gene].sum += log10Expression;
                geneSumCount[gene].count++;
            }
        }
    });

    // Calculate the average log10 expression for each gene
    var averageLog10Expressions = {};
    for (var gene in geneSumCount) {
        averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
    }

    return averageLog10Expressions;
}

  </script>
 
<div id="tooltip" style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px;"></div>
<div id="tTestResults"></div>



</body>
</html>

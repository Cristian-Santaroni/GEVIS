<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3.js Variation Histogram</title>
  <script src="d3.v7.8.5.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
  <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
  <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
  <style>
    #thresholdSlider {
      width: 10%;
    }
  </style>
</head>
<body>
  
  <h2>IQR frequency distribution</h2>
  
  <div>
    <label for="thresholdSlider">InterQuantile range:</label>
    <input type="range" id="thresholdSlider" min="0.1" max="0.99" step="0.01" value="0.1">
    <span id="thresholdValue">0.1</span>
  </div>
  <div id="IQR">
  </div>
  <div id="geneCount"></div>


  <h2>LogFC Histogram</h2>
  <div>
    <label for="log_thresholdSlider">LogFC threshold:</label>
    <input type="range" id="log_thresholdSlider" min="1.1" max="10" step="0.01" value="1.1">
    <span id="log_thresholdSliderValue">1.1</span>
  </div>

  <div id="logFCHistogram">
  </div>
  <div id="geneCount2"></div>
  <div id="scatterPlot"></div>


  <script>
    // Your existing JavaScript code goes here
    // Make sure to include the necessary libraries and define variables as needed

    function updateLogFCHistogram(logFCData) {
    // Extract logFC values and convert them to numbers
    const logFCValues = logFCData.map(entry => entry.logFC);

    // Define histogram parameters
    const svgWidth = 900;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 50, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    // Create SVG container
    const svg = d3.select("#logFCHistogram")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram using D3.js
    const histogram = d3.histogram()
        .value(d => d)
        .domain(d3.extent(logFCValues))
        .thresholds(100); // Number of bins

    const bins = histogram(logFCValues);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(logFCValues))
        .nice()
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .nice()
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "orange");

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .append("text")
        .attr("x", width / 2)
        .attr("y", margin.bottom * 0.8)
        .attr("text-anchor", "middle")
        .text("logFC");

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale))
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left * 0.7)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .text("frequency");

    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", -margin.top * 0.7)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .text("FC (logarithmic) frequency distribution");

    // Add ablines
    svg.append("line")
        .attr("x1", xScale(-Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(-Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    svg.append("line")
        .attr("x1", xScale(Math.log2(thr_fc)))
        .attr("y1", 0)
        .attr("x2", xScale(Math.log2(thr_fc)))
        .attr("y2", height)
        .style("stroke", "red")
        .style("stroke-width", "2");

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
            return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
        })
        .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
        .attr("width", d => {
            const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
            const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
            const barWidth = xScale(d.x1) - xScale(d.x0);
            // Calculate the width of the portion to color
            return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
        })
        .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
        .attr("fill", "grey") // Color the portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency

}


    </script>


  <script>
    //ocpu.seturl("//localhost/ocpu/lib/GEVIS/R")
    let variation_data;
    let variation_data_copy;
    let initial_num_genes;
    let data_upd
    let prc_IQR = 0.1;
    let thr_prc;
    let filteredData;
    let matrix;
    let data_original;
    let dataC_original;
    let dataN_original;
    let data_copy;
    let dataC_copy;
    let dataN_copy;
    let thr_fc = 1.1;
    let logFC_data;
    let log_thr_fc = Math.log2(thr_fc);
    let parsedLogFC;
    let parsedLogFC_origin;
    let newdataJSON
    let newdataCJSON
    let first_filter_number_genes;
    let p_val_adj;

    function calculateLogFC(dataC, dataN) {
    const logFCData = [];

    // Iterate over each gene
    Object.keys(dataC).forEach(gene => {
        // Get the values for the current gene from dataC and dataN
        let valuesC = Object.values(dataC[gene]);
        let valuesN = Object.values(dataN[gene]);

        // Pop the last value if it's a gene string
        let geneValueC;
        if (isNaN(valuesC[valuesC.length - 1])) {
            geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
        }
        let geneValueN;
        if (isNaN(valuesN[valuesN.length - 1])) {
            geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
        }

        // Calculate the row mean for dataC and dataN
        const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
        const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

        // Calculate the log fold change
        const logFC = rowMeanC - rowMeanN;

        // Push the gene and its logFC to logFCData
        logFCData.push({ "Gene": geneValueC, "logFC": logFC });
    });

    return logFCData

}



    function fetchJSON(url) {
      return fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          // Rename the key '_row' to 'Gene' in each object of the JSON array
          return data.map(obj => {
            const newObj = { ...obj };
            newObj['gene'] = newObj['_row'];
            delete newObj['_row']; // Delete the old key
            return newObj;
          });
        })
        .catch(error => {
          console.error('Error fetching JSON:', error);
        });
    }



    // Define a function to fetch data from a file with no header
    function fetchData(filename) {
    return fetch(filename)
    .then(response => response.text())
    .then(text => {
        // Parse the data
        const rows = text.trim().split('\n');
        
        // Extract sample GSM identifiers from the first row (excluding the first element)
        const sampleGSMs = rows[0].trim().split('\t').slice(1);

        // Map each row to an object representing gene expression for each sample
        matrix = rows.slice(1).map(row => {
            const [gene, ...expressions] = row.trim().split('\t');
            
            // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
            return {
                gene: gene,
                expressions: expressions.map(parseFloat)
            };
        });

        // Create a matrix with GSMs as headers
        const matrixWithHeaders = matrix.reduce((result, entry) => {
            const geneObj = {
                Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
            };
            result.push(geneObj);
            return result;
        }, []);
        return matrixWithHeaders; // Return the matrix with headers
    });
  }


    // Read the contents of the .txt file
    Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json')])
      .then(([dataC, dataN, data]) => {
        dataC_original = dataC
        dataN_original = dataN
        data_original = data
        fetch('variation_lung.txt')
          .then(response => response.text())
          .then(text => {
            // Parse the data
            const rows = text.split('\n');
            variation_data = rows.slice(1).map(row => {
              const [gene, variation] = row.trim().split('\t');
              return parseFloat(variation);
            });
            const row_length= rows.length-1
            initial_num_genes = row_length
            variation_data_copy = (variation_data);
            console.log("numero di geni iniziali prima di qualsiasi filtro "+row_length)


            thr_prc = ss.quantile(variation_data, prc_IQR);
            updateHistogram(variation_data);

            const ind = variation_data_copy.reduce((result, entry, index) => {
              
              if (entry < thr_prc) {
                result.push(index);
              }
              return result;
            }, []);

            if (ind.length > 0) {

              // Remove entries corresponding to ind from dataN
              data_copy = data_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from dataC
              dataC_copy = dataC_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from data
              dataN_copy = dataN_original.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from genes
              //genes = genes.filter((entry, index) => !ind.includes(index));

              // Remove entries corresponding to ind from logFC
              //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

            }
            // Update the gene count display
            const geneCountDiv = document.getElementById('geneCount');
            geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

            first_filter_number_genes = data_copy.length

            parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
            parsedLogFC = parsedLogFC_origin
            
            //console.log(dataC_copy)
            //console.log(dataN_copy)

            var averageExpressionsC = calculateAverageExpressions(dataC_copy);
            var averageExpressionsN = calculateAverageExpressions(dataN_copy);

            var averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
            var averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);




            //console.log(averageExpressionsC);
            //console.log(averageExpressionsN);
            updateLogFCHistogram(parsedLogFC_origin)
            //updateScatterPlot(averageExpressionsN,averageExpressionsC)
            //updateScatterPlot(averageExpressions10N,averageExpressions10C)

                  // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);  

            updateScatterPlot(averageExpressionsN,averageExpressionsC,log_thr_fc,parsedLogFC_origin)
            updateScatterPlot(averageExpressions10N,averageExpressions10C,log_thr_fc,parsedLogFC_origin)


            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

          const geneCountDiv2 = document.getElementById('geneCount2');
          geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


          })
          .catch(error => console.error('Error reading file:', error));
        });

  function calculateAverageExpressions(dataArray) {
    // Create an object to store the sum and count for each gene
    var geneSumCount = {};

    // Iterate through each gene object in the array
    dataArray.forEach(function (geneData) {
        var gene = geneData.gene;

        // Iterate through each property (sample) in the gene object
        for (var sample in geneData) {
            if (sample !== 'gene') {
                // If the gene is not in the sumCount object, initialize it
                if (!geneSumCount[gene]) {
                    geneSumCount[gene] = { sum: 0, count: 0 };
                }

                // Add the expression value to the sum and increment the count
                geneSumCount[gene].sum += parseFloat(geneData[sample]);
                geneSumCount[gene].count++;
            }
        }
    });

    // Calculate the average for each gene
    var averageExpressions = {};
    for (var gene in geneSumCount) {
        averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
    }

    return averageExpressions;
}

function calculateAverageLog10Expressions(dataArray) {
    // Create an object to store the sum and count for each gene
    var geneSumCount = {};

    // Iterate through each gene object in the array
    dataArray.forEach(function (geneData) {
        var gene = geneData.gene;

        // Iterate through each property (sample) in the gene object
        for (var sample in geneData) {
            if (sample !== 'gene') {
                // If the gene is not in the sumCount object, initialize it
                if (!geneSumCount[gene]) {
                    geneSumCount[gene] = { sum: 0, count: 0 };
                }

                // Apply Math.log10 to the expression value before summing
                var log10Expression = Math.log2(parseFloat(geneData[sample]));

                // Add the log10 expression value to the sum and increment the count
                geneSumCount[gene].sum += log10Expression;
                geneSumCount[gene].count++;
            }
        }
    });

    // Calculate the average log10 expression for each gene
    var averageLog10Expressions = {};
    for (var gene in geneSumCount) {
        averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
    }

    return averageLog10Expressions;
}
      

    document.getElementById("thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      prc_IQR = parseFloat(this.value);
      document.getElementById("thresholdValue").innerText = prc_IQR;

      // Calculate the quantile
      thr_prc = ss.quantile(variation_data_copy, prc_IQR);
      updateHistogram(variation_data);

      const ind = variation_data_copy.reduce((result, entry, index) => {
        
        if (entry <= thr_prc) {
          result.push(index);
        }
        return result;
      }, []);

      if (ind.length > 0) {
        // Remove entries corresponding to ind from dataC
        dataC_copy = dataC_original.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from data
        dataN_copy = dataN_original.filter((entry, index) => !ind.includes(index));
        // Remove entries corresponding to ind from genes
        //genes = genes.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from logFC
        //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

      }
      // Update the gene count display
      const geneCountDiv = document.getElementById('geneCount');
      geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${dataC_copy.length}`;

      first_filter_number_genes = dataC_copy.length

      parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
      parsedLogFC = parsedLogFC_origin

      updateLogFCHistogram(parsedLogFC_origin)

      //updateScatterPlot(parsedLogFC_origin)


      log_thr_fc = Math.log2(thr_fc);  
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

      const geneCountDiv2 = document.getElementById('geneCount2');
      geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length - ind2.length}`;

    });

    document.getElementById("thresholdSlider").addEventListener("change", function() {

      const ind = variation_data_copy.reduce((result, entry, index) => {
        
        if (entry <= thr_prc) {
          result.push(index);
        }
        return result;
      }, []);

      if (ind.length > 0) {

        // Remove entries corresponding to ind from dataN
        data_copy = data_original.filter((entry, index) => !ind.includes(index));

        // Remove entries corresponding to ind from genes
        //genes = genes.filter((entry, index) => !ind.includes(index));


      }
      // Update the gene count display
      const geneCountDiv = document.getElementById('geneCount');
      geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

      first_filter_number_genes = data_copy.length

      log_thr_fc = Math.log2(thr_fc);  
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
          
                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                  result.push(index);
                }
                return result;
            }, []);

      const geneCountDiv2 = document.getElementById('geneCount2');
      geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;



    });

    document.getElementById("log_thresholdSlider").addEventListener("input", function() {
      // Update the threshold value on slider change
      thr_fc = parseFloat(this.value);
      document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

      // Calculate the quantile
      log_thr_fc = Math.log2(thr_fc);  
      const ind = parsedLogFC_origin.reduce((result, entry, index) => {
          
          if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            result.push(index);
            
          }
          return result;
        }, []);

        if (ind.length>0){
          parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
        }

      const geneCountDiv = document.getElementById('geneCount2');
      geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

      // Call the updateHistogram function directly
      updateLogFCHistogram(parsedLogFC_origin);
    });

    document.getElementById("log_thresholdSlider").addEventListener("change", function() {

      console.log("sono dentro")
      console.log("threshold "+thr_fc)
        // Find indices where abs(logFC) < log2(thr_fc)
        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
          
          if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            result.push(index);
            
          }
          return result;
        }, []);

        
      
        
        if (ind.length > 0) {

          console.log(parsedLogFC.length)

          // Remove entries corresponding to ind from dataN

          // Remove entries corresponding to ind from dataN
          dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from dataN
          dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));

          data_copy = data_copy.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from genes
          //   genes = genes.filter((entry, index) => !ind.includes(index));

          // Remove entries corresponding to ind from logFC
          parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
          
          console.log(parsedLogFC.length)

        }

        const geneCountDiv = document.getElementById('geneCount2');
        geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

        // Now, dataN, dataC, data, genes, and logFC are updated
    })


    function updateScatterPlot(averageExpressionsN, averageExpressionsC,log_thr_fc,parsedLogFC_origin) {
    // Set up margin, width, and height
    var margin = { top: 10, right: 30, bottom: 30, left: 60 };
    var width = 600 - margin.left - margin.right;
    var height = 400 - margin.top - margin.bottom;

  

    // Create x and y scales
    var xScale = d3.scaleLinear()
        .domain(d3.extent(Object.values(averageExpressionsN)))
        .range([0, width]);

    var yScale = d3.scaleLinear()
        .domain(d3.extent(Object.values(averageExpressionsC)))
        .range([height, 0]);

    // Create SVG container
    var svg = d3.select("#scatterPlot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Add X axis
    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale));

    // Add Y axis
    svg.append("g")
        .call(d3.axisLeft(yScale));

    //console.log(parsedLogFC_origin)
    // Create circles for each gene
    var data = Object.keys(averageExpressionsN).map(function (gene) {
    // Find the corresponding logFC value from parsedLogFC_origin
    var logFCObj = parsedLogFC_origin.find(d => d.Gene === gene) || null;
    var logFC = logFCObj ? logFCObj.logFC : null;

    return { gene: gene, x: averageExpressionsN[gene], y: averageExpressionsC[gene], logFC: logFC };
});
    console.log(data)

    svg.selectAll("circle")
    .data(data)
    .enter().append("circle")
    .attr("cx", d => xScale(d.x))
    .attr("cy", d => yScale(d.y))
    .attr("r", 5)
    .style("fill", d => {
        // Check if logFC is greater than or equal to the threshold
        if (d.logFC >= log_thr_fc) {
            return "red";
        } else if(d.logFC <= -(log_thr_fc)) {
            return "blue";
        }
        else{
          return "yellow"
        }
    })
    .on("mouseover", function (event, d) {
        // Add tooltip or other interactions if needed
        // Example: console.log("Mouseover:", d.gene);
    });
}




    function updateHistogram(variation_data) {
    // Filter data based on the threshold
    const filteredData = variation_data.filter(variation => variation >= thr_prc);

    // Create histogram using D3.js
    const svgWidth = 900;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 30, left: 50 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;

    const svg = d3.select("#IQR")
        .html("")  // Clear previous content
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create histogram
    const histogram = d3.histogram()
        .value(variation => variation)
        .domain(d3.extent(variation_data))
        .thresholds(100);

    const bins = histogram(variation_data);

    const xScale = d3.scaleLinear()
        .domain(d3.extent(variation_data))
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.length)])
        .range([height, 0]);

    // Add histogram bars
    svg.selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", d => xScale(d.x0))
        .attr("y", d => yScale(d.length))
        .attr("width", d => xScale(d.x1) - xScale(d.x0))
        .attr("height", d => height - yScale(d.length))
        .attr("fill", d => {
            const thresholdPosition = xScale(thr_prc);
            if (xScale(d.x1) < thresholdPosition) {
                return "grey"; // Set the color to grey if d.x1 is less than the threshold
            } else {
                return "steelblue"; // Set the original bar color
            }
        });

    // Add overlay for colored portion
    svg.selectAll(".overlay")
        .data(bins)
        .enter()
        .append("rect")
        .attr("class", "overlay")
        .attr("x", d => {
            const thresholdPosition = xScale(thr_prc);
            return xScale(d.x0); // Start the overlay from the beginning of the bar
        })
        .attr("y", d => yScale(d.length))
        .attr("width", d => {
            const thresholdPosition = xScale(thr_prc);
            const barWidth = xScale(d.x1) - xScale(d.x0);
            if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                // Calculate the width of the portion to color
                return thresholdPosition - xScale(d.x0); // Only color the left portion
            } else {
                return 0; // Set width to 0 for bars where threshold is not in range
            }
        })
        .attr("height", d => height - yScale(d.length))
        .attr("fill", "grey") // Color the left portion of the overlay
        .attr("opacity", 1); // Set opacity for transparency

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale));

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale));

    // Add a red line indicating the threshold
    const thresholdLine = svg.append("line")
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "red")
        .attr("stroke-width", 2);

    // Update the position of the threshold line
    thresholdLine.attr("x1", xScale(thr_prc))
        .attr("x2", xScale(thr_prc));
}

  </script><button id="computePValuesButton">P-VALUE</button>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics-extras@1.2.0/dist/simple-statistics-extras.min.js"></script>

 <script>

  
  // Assuming newdataNJSON, newdataCJSON, and newdataJSON are your arrays of data
  document.getElementById("computePValuesButton").addEventListener("click", function() {
    console.log(dataC_copy)
    console.log(data_copy)
    console.log(dataN_copy)
    
      var req = ocpu.call("hello", {
            data: data_copy,
            dataC: dataC_copy,
            dataN: dataN_copy
        }, function(session) {
            var filteredDataURL = session.loc + "/R/.val/json";
            console.log(session);
            // Fetch the filtered data from the URL
            fetch(filteredDataURL)
                .then(response => response.json())
                .then(data => {
                  p_val_adj=data
                  console.log(data)

                
      const ind = p_val_adj.reduce((result, entry, index) => {
          
          if (entry.pval_adj > 0.05) {
            result.push(index);
          }
          return result;
        }, []);

        if (ind.length > 0) {

            //console.log(parsedLogFC.length)

            // Remove entries corresponding to ind from dataN

            // Remove entries corresponding to ind from dataN
            dataC_copy = dataC_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from dataN
            dataN_copy = dataN_copy.filter((entry, index) => !ind.includes(index));


            data_copy = data_copy.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from genes
            //   genes = genes.filter((entry, index) => !ind.includes(index));

            // Remove entries corresponding to ind from logFC
            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

            //console.log(parsedLogFC.length)

            console.log(data_copy)
            console.log(dataN_copy)
            console.log(dataC_copy)

                              }

      });
    })

});


  </script>

<div id="tTestResults"></div>



</body>
</html>

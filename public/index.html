<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Variation Histogram</title>
    <script src="d3.v7.8.5.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
    <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"
        integrity="sha512-5mCB0Kvv97yTzqo0174qxPjMisck/WlK51+mw/RV7UfYbtHI8LuLR82BzZuxHUKSfbh75u9cZHgUcqrZDaBJuA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <script src="css/bootstrap.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-color/3.0.0/d3-color.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-interpolate/1.5.0/d3-interpolate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale/3.2.2/d3-scale.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale-chromatic/1.6.0/d3-scale-chromatic.min.js"></script>

    <style>
        .axis-label {
            cursor: pointer;
            /* Cursor style when hovering over the axis label */
        }

        .dragging {
            cursor: move;
            /* Cursor style during dragging */
        }


        #thresholdSlider {
            width: 5%;
        }

        .flex {
            display: flex;
            flex-direction: row;
            max-width: space-between;
            height: 100%;
            width: 100%
        }

        .flex-container {
            display: flex;
            flex-direction: column;
            max-width: fit-content;

        }

        .flex-container>div {
            margin-right: 3.2px;
            /* Add spacing between items */
        }


        body {
            background-color: black;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }


        #style_scatter {
            border: 2px solid #ddd;
            /* Border color */
            /* Border radius for rounded corners */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            /* Shadow effect */
            background-color: rgb(38, 38, 38);
        }


        input.range1 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range1:focus-visible,
        input.range1:hover {
            --p: 25%;
        }

        /* chromium */
        input.range1[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, orange 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        /* Second range slider with a different color scheme */
        input.range2 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range2:focus-visible,
        input.range2:hover {
            --p: 25%;
        }

        /* chromium */
        input.range2[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, darkgreen 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        @supports not (color: color-mix(in srgb, red, red)) {
            input {
                --_c: var(--c);
            }
        }

        @keyframes pulseAnimation {
            0% {
                fill: green;
                r: 2;
            }

            50% {
                fill: lime;
                /* Color during the pulse */
                r: 4
            }

            100% {
                fill: green;
                r: 2
            }
        }

        .pulse {
            animation: pulseAnimation 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseAnimation1 {
            0% {

                r: 2;
            }

            50% {

                r: 4
            }

            100% {

                r: 2
            }
        }

        .pulse1 {
            animation: pulseAnimation1 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseRedAnimation {
            0% {
                stroke: aqua;
                /* Initial color */
                stroke-width: 2;
                /* Initial stroke width */
            }

            50% {
                stroke: rgb(198, 255, 255);
                /* Color during the pulse */
                stroke-width: 3;
                /* Increased stroke width during the pulse */
            }

            100% {
                stroke: aqua;
                /* Back to initial color */
                stroke-width: 2;
                /* Back to initial stroke width */
            }
        }

        .pulse-red {
            animation: pulseRedAnimation 1s infinite;
            /* Adjust duration as needed */
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent black background */
            z-index: 9999;
            /* Ensure the overlay appears above other elements */
            display: block;
            /* Initially hidden */
        }

        /* You can customize the loading indicator style here */
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            /* Add more styles as needed */
        }
    </style>
</head>

<body>

    <div id="loadingOverlay" style="display: flex; justify-content: center; align-items: center;">
        <div style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">

            <svg version="1.1" id="L1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                x="0px" y="0px" viewBox="0 0 50 50" enable-background="new 0 0 100 100" xml:space="preserve"
                style="width: 50px; height: 50px;">
                <circle fill="none" stroke="#98AFC7" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="21">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="360 25 25" repeatCount="indefinite" />
                </circle>
                <circle fill="none" stroke="#98AFC7" stroke-width="1" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="18">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="-360 25 25" repeatCount="indefinite" />
                </circle>
                <g fill="#98AFC7">
                    <rect x="15" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.1" />
                    </rect>
                    <rect x="20" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.2" />
                    </rect>
                    <rect x="25" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.3" />
                    </rect>
                    <rect x="30" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.4" />
                    </rect>
                    <rect x="35" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.5" />
                    </rect>
                </g>
            </svg>
        </div>
    </div>

    <div class="flex"> <!-- div(1) che mette in colonna-->

        <div class="flex-container" style="margin-top : 6px; margin-left : 6px"><!--div(2) che mette in riga iqr e FC-->
            <div id="style_scatter">

                <div id="IQR" style="width: 100%"></div><!--div(4) IQR-->
                <div> <!--div(3) bottoni IQR-->
                    <input type="range" id="thresholdSlider" class="range2" min="0.1" max="0.99" step="0.01" value="0.1"
                        style="width: 200px;">
                    <span id="thresholdValue" style="color: white;">0.1</span>
                </div><!-- div(3)-->
                <div id="logFCHistogram"></div> <!-- div(5) FC-->

                <div><!-- div(6) bottoni FC-->

                    <input type="range" id="log_thresholdSlider" class="range1" min="1.1" max="10" step="0.01"
                        value="1.1" style="width: 200px;">
                    <span id="log_thresholdSliderValue" style="color: white;">1.1</span>
                    <div id="boxPlot"></div>
                    <!-- Initialize a select button -->
                    <select id="selectButton" class="btn btn-secondary dropdown-toggle">
                        <option value="SPP1" selected>MostUp</option>
                        <option value="AGER">MostdDown</option>
                    </select>

                </div><!--div(6)-->
            </div>
        </div><!--div(2)-->

        <div>
            <div class="flex-container" style="margin-top : 6px;">
                <div id="style_scatter">
                    <div id="scatterPlot"></div>
                    <button id="resetButton" class="btn btn-secondary">Reset
                        Zoom</button>
                    <label for="thresholdSelect">
                        <p style="color: #ddd;">Select
                            Threshold:</p>
                    </label>
                    <select id="thresholdSelect" class="btn btn-secondary dropdown-toggle">
                        <option value="0.05" selected>0.05</option>
                        <option value="0.01">0.01</option>
                    </select>
                </div>

                <div id="style_scatter">
                    <div class="flex">
                        <div id="checkbox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden;">
                            <label for="vehicle1" class="btn btn-secondary active"
                                style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle1" name="vehicle1" value="Age" checked
                                    onchange="handleCheckboxChange()">
                                Age</label>

                            <label for="vehicle2" class="btn btn-secondary" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle2" name="vehicle2" value="Smoker"
                                    onchange="handleCheckboxChangeCigarettes()">
                                Smoker class</label>

                            <label for="vehicle3" class="btn btn-secondary" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle3" name="vehicle3" value="Gender"
                                    onchange="handleCheckboxChangeGender()">
                                Gender</label>

                            <label for="vehicle4" class="btn btn-secondary" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle4" name="vehicle4" value="Stage"
                                    onchange="handleCheckboxChangeStage()">
                                Stage</label>

                            <label for="vehicle5" class="btn btn-secondary" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle5" name="vehicle5" value="type"
                                    onchange="handleCheckboxChangeType()">
                                Type</label>
                        </div>
                        <div id="radiobox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden; margin-left: 10%;">

                            <label for="variable1" class="btn btn-secondary active"
                                style="color: #ddd;  margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable1" name="variable" autocomplete="off" value="case"
                                    checked>
                                Case/Normal</label>


                            <label for="variable2" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable2" name="variable" autocomplete="off" value="Smoker">
                                Smoker class</label>


                            <label for="variable3" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable3" name="variable" autocomplete="off" value="Gender">
                                Gender</label>


                            <label for="variable4" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable4" name="variable" autocomplete="off" value="Stage">
                                Stage</label>
                        </div>
                        <!-- Add this div for the legend -->
                    </div>
                    <div id="parallelLegend" style="margin-top: 2px; color: #ddd;"></div>
                    <div id="parallelcoordinates" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div class="flex-container" style="margin-top : 6px;">

            <div id="style_scatter">
                <div>
                    <div id="pca"></div>

                </div>
                <div id="heatmap"></div>

            </div>

            <div id="style_scatter"
                style="display: flex; justify-content: center; align-items: center; height: 100%; width: 99.5%;">
                <div class="flex"
                    style="display: flex; justify-content: center; align-items: center; height: 100%; width: 100%;">
                    <div id="counter"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; border-left: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                    <div id="counter1"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                </div>
            </div>

        </div>

    </div> <!-- div(1)-->

    <script>
        try {
            ocpu.seturl("//localhost/ocpu/lib/GEVIS/R");
        } catch (error) {
            // If an error occurs (e.g., ocpu is not defined), reload the page
            window.location.reload();
        }
        let variation_data;
        let variation_data_copy;
        let initial_num_genes;
        let data_upd
        let prc_IQR = 0.1;
        let thr_prc;
        let filteredData;
        let matrix;
        let data_original = [];
        let dataC_original = [];
        let dataN_original = [];
        let data_copy = [];
        let dataC_copy = [];
        let dataN_copy = [];
        let data_copy1 = [];
        let dataC_copy1 = [];
        let dataN_copy1 = [];
        let thr_fc = 1.1;
        let logFC_data;
        let log_thr_fc = Math.log2(thr_fc);
        let parsedLogFC;
        let parsedLogFC_origin;
        let parsedLogFC_origin1;
        let newdataJSON
        let newdataCJSON
        let first_filter_number_genes;
        let p_val_adj;
        let threshold = 0.05;
        let averageExpressions10C;
        let averageExpressions10N;
        let averageExpressionsC;
        let averageExpressionsN;
        let selectedGeneData = [];
        let greencircles = []
        let old_p_adj
        let transposedData = [];
        let ordering
        let metadata;
        let combinedData = []
        let combinedData1 = []
        let gsmList = []

        var json = []
        //info box plot
        let sumstat1
        var scatter;
        let sumstat
        var geneNameUP
        var geneNameDown
        let first_box = true
        /////////
        var currentCircleFill
        var first_dims = ['Age at Diagnosis']

        // Remove entries corresponding to ind from dataN
        var dataC_copy_pval

        // Remove entries corresponding to ind from dataN
        var dataN_copy_pval


        var data_copy_pval

        // Remove entries corresponding to ind from logFC
        var parsedLogFC_pval
        var color_by = 'case'
        let pca_data = []
        let heatmap_data = []
        let square;

        let selectedVariable = "case"




        function calculateLogFC(dataC, dataN) {
            const logFCData = [];

            // Iterate over each gene
            Object.keys(dataC).forEach(gene => {
                // Get the values for the current gene from dataC and dataN
                let valuesC = Object.values(dataC[gene]);
                let valuesN = Object.values(dataN[gene]);

                // Pop the last value if it's a gene string
                let geneValueC;
                if (isNaN(valuesC[valuesC.length - 1])) {
                    geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
                }
                let geneValueN;
                if (isNaN(valuesN[valuesN.length - 1])) {
                    geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
                }

                // Calculate the row mean for dataC and dataN
                const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
                const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

                // Calculate the log fold change
                const logFC = rowMeanC - rowMeanN;

                // Push the gene and its logFC to logFCData
                logFCData.push({ "Gene": geneValueC, "logFC": logFC });
            });

            return logFCData

        }


        function fetchJSON(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Rename the key '_row' to 'Gene' in each object of the JSON array
                    return data.map(obj => {
                        const newObj = { ...obj };
                        newObj['gene'] = newObj['_row'];
                        delete newObj['_row']; // Delete the old key
                        return newObj;
                    });
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        function fetchMeta(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        // Define a function to fetch data from a file with no header
        function fetchData(filename) {
            return fetch(filename)
                .then(response => response.text())
                .then(text => {
                    // Parse the data
                    const rows = text.trim().split('\n');

                    // Extract sample GSM identifiers from the first row (excluding the first element)
                    const sampleGSMs = rows[0].trim().split('\t').slice(1);

                    // Map each row to an object representing gene expression for each sample
                    matrix = rows.slice(1).map(row => {
                        const [gene, ...expressions] = row.trim().split('\t');

                        // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
                        return {
                            gene: gene,
                            expressions: expressions.map(parseFloat)
                        };
                    });

                    // Create a matrix with GSMs as headers
                    const matrixWithHeaders = matrix.reduce((result, entry) => {
                        const geneObj = {
                            Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                            ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
                        };
                        result.push(geneObj);
                        return result;
                    }, []);
                    return matrixWithHeaders; // Return the matrix with headers
                });
        }

        var width = 100,
            height = 100,
            n = 18,
            r = 5,
            π = Math.PI,
            p = 1000;
        const margin = { top: 10, right: 20, bottom: 30, left: 130 };

        var svg = d3.select("#scatterPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        var gScatter = svg.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsScatter = gScatter.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsScatter.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        const margin1 = { top: 10, right: 20, bottom: 30, left: 5 };
        var svg1 = d3.select("#boxPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin1.left},${margin1.top})`);

        var gBoxPlot = svg1.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsBoxPlot = gBoxPlot.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsBoxPlot.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        function moon(θ) {
            var rx0 = θ < π ? r : -r,
                s0 = θ < π ? 0 : 1,
                rx1 = r * Math.cos(θ),
                s1 = θ < π / 2 || (π <= θ && θ < 3 * π / 2) ? 0 : 1;
            return "M" + [0, r] +
                "A" + [rx0, r, 0, 0, s0, 0, -r] +
                "A" + [rx1, r, 0, 0, s1, 0, r];
        }


        // Read the contents of the .txt file
        Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json'), fetchMeta('metadata.json')])
            .then(([dataC, dataN, data, meta]) => {
                dataC_original = dataC
                dataN_original = dataN
                data_original = data
                metadata = meta
                fetch('variation_lung.txt')
                    .then(response => response.text())
                    .then(text => {
                        // Parse the data
                        const rows = text.split('\n');
                        variation_data = rows.slice(1).map(row => {
                            const [gene, variation] = row.trim().split('\t');
                            return parseFloat(variation);
                        });
                        const row_length = rows.length - 1
                        initial_num_genes = row_length
                        variation_data_copy = (variation_data);
                        console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)

                        thr_prc = ss.quantile(variation_data, prc_IQR);
                        updateHistogram(variation_data);

                        const ind = variation_data_copy.reduce((result, entry, index) => {

                            if (entry < thr_prc) {
                                result.push(index);
                            }
                            return result;
                        }, []);

                        if (ind.length > 0) {

                            // Remove entries corresponding to ind from dataN
                            data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from dataC
                            dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from data
                            dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from genes
                            //genes = genes.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from logFC
                            //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                        }

                        dataN_copy = dataN_copy1
                        dataC_copy = dataC_copy1
                        data_copy = data_copy1
                        console.log("geni tolti dal primo filtering del IQR", ind.length)

                        // Update the gene count display
                        // const geneCountDiv = document.getElementById('geneCount');
                        // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

                        first_filter_number_genes = data_copy.length

                        parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                        parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                        parsedLogFC = parsedLogFC_origin

                        //  console.log("first parsed origin after",parsedLogFC_origin.length)
                        //  console.log("first data orign afterN ",dataN_copy.length)
                        //  console.log("first data orign afterC ",dataC_copy.length)

                        averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                        averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);


                        fetch('genes_and_pval_adj.json')
                            .then(response => response.json())
                            .then(data => {
                                p_val_adj = data

                                // Calculate the quantile
                                log_thr_fc = Math.log2(1.1);
                                //console.log(log_thr_fc)
                                const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);

                                    }
                                    return result;
                                }, []);
                                console.log("geni tolti dal primo filtering del LOGFC", ind.length)

                                // console.log("parsed log before ",parsedLogFC.length)
                                // console.log("data copy beforeC ",dataC_copy.length)
                                // console.log("data copy beforeN ",dataN_copy.length)

                                // console.log("parsed log origin ",parsedLogFC_origin.length)
                                /////////////////////// 

                                //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

                                //////////////////////
                                // console.log(parsedLogFC_origin)
                                // console.log(data_copy)
                                if (ind.length > 0) {

                                    // Remove entries corresponding to ind from dataN
                                    dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                                    // Remove entries corresponding to ind from dataN
                                    dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                                    data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                                    parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                }

                                //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                // console.log(parsedLogFC)
                                // console.log(data_copy)

                                updateLogFCHistogram(parsedLogFC_origin)

                                var req = ocpu.call("hello", {
                                    data: data_copy
                                }, function (session) {
                                    var filteredDataURL = session.loc + "/R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            old_p_adj = data
                                            const ind = old_p_adj.reduce((result, entry, index) => {

                                                if (entry.pval_adj > threshold) {
                                                    result.push(index);
                                                }
                                                return result;
                                            }, []);


                                            console.log("geni tolti dal primo filtering del pval", ind.length)

                                            if (ind.length > 0) {

                                                //console.log(parsedLogFC.length)

                                                // Remove entries corresponding to ind from dataN

                                                // Remove entries corresponding to ind from dataN
                                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                // Remove entries corresponding to ind from dataN
                                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                // Remove entries corresponding to ind from logFC
                                                parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                // updateBoxPlot1(parsedLogFC,dataN_copy,dataC_copy)


                                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                var mostUpregulatedGene = sortedLogFC[0];
                                                var secondMostUpregulatedGene = sortedLogFC[1];

                                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                                                genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]

                                                selectedGeneData.push(mostUpregulatedGeneName)
                                                selectedGeneData.push(mostDownregulatedGeneName)



                                                updateParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                updateCounter()

                                                scatter.selectAll("circle")
                                                    .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                                    .style("fill", d => {
                                                        // Check if logFC is greater than or equal to the threshold
                                                        return "green";

                                                    })
                                                    .classed('pulse', true);


                                                document.getElementById("checkbox").style.visibility = "visible";
                                                document.getElementById("radiobox").style.visibility = "visible";


                                            }
                                            console.log(dataN_copy.length)
                                            var pc1Values = [];
                                            var pc2Values = [];
                                            var groupValues = [];
                                            var req = ocpu.call("pca", {
                                                data: data_copy,
                                                dataN: dataN_copy,
                                                dataC: dataC_copy
                                            }, function (session) {
                                                var filteredDataURL = session.loc + "/R/.val/json";
                                                //console.log(session);
                                                // Fetch the filtered data from the URL
                                                fetch(filteredDataURL)
                                                    .then(response => response.json())
                                                    .then(data => {
                                                        json = data
                                                        console.log(filteredDataURL)
                                                        console.log(json)

                                                        var pc1Key = "PC1";
                                                        var pc2Key = "PC2";
                                                        var groupKey = "Group";

                                                        // Arrays to store PC1 and PC2 values


                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            pc1Values.push(obj[pc1Key]);
                                                            pc2Values.push(obj[pc2Key]);
                                                            groupValues.push(obj[groupKey]);
                                                        });
                                                        // console.log(pc1Values)

                                                        pca_data = [];

                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Retrieve additional data from metadata based on _row
                                                            var gsm = obj._row;
                                                            var group = obj.Group;

                                                            // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                                            var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                            var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                            var pc1 = obj.PC1;
                                                            var pc2 = obj.PC2;

                                                            // Create an object with the required fields
                                                            var newObj = {
                                                                GSM: gsm,
                                                                group: group,
                                                                smokerclass: smokerclass,
                                                                stage: stage,
                                                                pc1: pc1,
                                                                pc2: pc2
                                                            };

                                                            // Push the new object to the newData array
                                                            pca_data.push(newObj);


                                                        });
                                                        heatmap_data = []
                                                        json.scores_var.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            var gene = obj._row
                                                            var pc1 = obj.PC1
                                                            var pc2 = obj.PC2
                                                            var pc3 = obj.PC3
                                                            var pc4 = obj.PC4
                                                            var pc5 = obj.PC5
                                                            var pc6 = obj.PC6

                                                            var newObj = {
                                                                gene: gene,
                                                                pc1: pc1,
                                                                pc2: pc2,
                                                                pc3: pc3,
                                                                pc4: pc4,
                                                                pc5: pc5,
                                                                pc6: pc6
                                                            };
                                                            heatmap_data.push(newObj);
                                                        })
                                                        // Display the newData array
                                                        //console.log(pca_data);


                                                        pca(pca_data);
                                                        heatmap(heatmap_data);

                                                    })





                                            })
                                        });


                                })
                                ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////


                                // Calculate the quantile
                                log_thr_fc = Math.log2(thr_fc);

                            })
                        const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                result.push(index);
                            }
                            return result;
                        }, []);

                        // const geneCountDiv2 = document.getElementById('geneCount2');
                        // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


                    })
                    .catch(error => console.error('Error reading file:', error));

            });

        document.getElementById("thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            prc_IQR = parseFloat(this.value);
            document.getElementById("thresholdValue").innerText = prc_IQR;

            // Calculate the quantile
            thr_prc = ss.quantile(variation_data_copy, prc_IQR);
            updateHistogram(variation_data);

            const ind = variation_data_copy.reduce((result, entry, index) => {

                if (entry <= thr_prc) {
                    result.push(index);
                }
                return result;
            }, []);

            console.log("geni tolti con IQR", ind.length)
            if (ind.length > 0) {
                // Remove entries corresponding to ind from dataC
                dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from data
                dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from genes
                //genes = genes.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from logFC
                //parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

            }
            // Update the gene count display
            // const geneCountDiv = document.getElementById('geneCount');
            // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${dataC_copy1.length}`;

            first_filter_number_genes = dataC_copy.length

            parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
            parsedLogFC = parsedLogFC_origin


            //console.log(parsedLogFC_origin)
            updateLogFCHistogram(parsedLogFC_origin)


            // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);
            //console.log(log_thr_fc)
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                    result.push(index);

                }
                return result;
            }, []);

            console.log("geni da togliere con il logFC da IQR", ind2.length)
            console.log("ora rimuovo questi geni da data che partiva da", data_copy1.length)

            // console.log("parsed log before ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN ",dataN_copy.length)

            // console.log("parsed log origin ",parsedLogFC_origin.length)
            /////////////////////// 

            //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

            //////////////////////

            // console.log(parsedLogFC_origin)
            // console.log(data_copy1)

            if (ind2.length > 0) {
                //console.log("ind2")
                // Remove entries corresponding to ind from dataN
                dataC_copy = dataC_copy1.filter((entry, index) => !ind2.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy = dataN_copy1.filter((entry, index) => !ind2.includes(index));

                data_copy = data_copy1.filter((entry, index) => !ind2.includes(index));

                parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind2.includes(index));
            }

            console.log("ho rimosso", ind2.length, " GENI da data e ne rimangono ", data_copy.length)
            updateCounter()
            // console.log(parsedLogFC)
            // console.log(data_copy)

            // log_thr_fc = Math.log2(thr_fc);  
            //       const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

            //           if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            //             result.push(index);
            //           }
            //           return result;
            //       }, []);


            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length - ind2.length}`;

        });

        document.getElementById("thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";

            console.log("data copy in iqr prima di chiamare pval", data_copy)
            var req = ocpu.call("hello", {
                data: data_copy
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(session);
                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {

                        old_p_adj = data

                        averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                        averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin, old_p_adj)





                        const ind = old_p_adj.reduce((result, entry, index) => {

                            if (entry.pval_adj > threshold) {
                                result.push(index);
                            }
                            return result;
                        }, []);
                        console.log("geni con pval minore di thr nel iqr slider", ind.length)
                        console.log("thr pval ", threshold)
                        if (ind.length > 0) {

                            //console.log(parsedLogFC.length)

                            // Remove entries corresponding to ind from dataN

                            // Remove entries corresponding to ind from dataN
                            dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from dataN
                            dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                            data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from logFC
                            parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                            console.log("geni passati a box dal IQR slider", parsedLogFC.length)
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            updateBoxPlot1(parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)


                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                selectedGeneData.push(mostUpregulatedGeneName)
                                selectedGeneData.push(mostDownregulatedGeneName)

                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }



                            updateParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)
                            updateCounter()
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "/R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;

                                            // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                            var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                            var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                            var pc1 = obj.PC1;
                                            var pc2 = obj.PC2;

                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                                smokerclass: smokerclass,
                                                stage: stage,
                                                pc1: pc1,
                                                pc2: pc2
                                            };

                                            // Push the new object to the newData array
                                            pca_data.push(newObj);

                                        });


                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row
                                            var pc1 = obj.PC1
                                            var pc2 = obj.PC2
                                            var pc3 = obj.PC3
                                            var pc4 = obj.PC4
                                            var pc5 = obj.PC5
                                            var pc6 = obj.PC6

                                            var newObj = {
                                                gene: gene,
                                                pc1: pc1,
                                                pc2: pc2,
                                                pc3: pc3,
                                                pc4: pc4,
                                                pc5: pc5,
                                                pc6: pc6
                                            };
                                            heatmap_data.push(newObj);
                                        })

                                        // Display the newData array
                                        console.log(pca_data);


                                        pca(pca_data);
                                        heatmap(heatmap_data)

                                    })





                            })
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    return "green";

                                });

                        }


                    });
            })



            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;

        });


        document.getElementById("log_thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            thr_fc = parseFloat(this.value);
            document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

            // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);
            //console.log(log_thr_fc)
            const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                    result.push(index);

                }
                return result;
            }, []);

            if (ind.length > 0) {

                // Remove entries corresponding to ind from dataN
                dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
            }

            updateCounter()
            updateLogFCHistogram(parsedLogFC_origin);

        });

        document.getElementById("log_thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";

            var req = ocpu.call("hello", {
                data: data_copy
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(session);
                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {
                        old_p_adj = data

                        averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                        averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin, old_p_adj)

                        selectedGeneData = selectedGeneData.filter(function (gene) {
                            // Check if the gene is present in dataC_copy or dataN_copy
                            return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                dataN_copy.some(function (d) { return d.gene === gene; });
                        });

                        console.log(selectedGeneData)

                        updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                        const ind = old_p_adj.reduce((result, entry, index) => {

                            if (entry.pval_adj > threshold) {
                                result.push(index);
                            }
                            return result;
                        }, []);

                        console.log("geni con pval minore di thr nel logFC slider", ind.length)

                        if (ind.length > 0) {

                            //console.log(parsedLogFC.length)

                            // Remove entries corresponding to ind from dataN

                            // Remove entries corresponding to ind from dataN
                            dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from dataN
                            dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));

                            data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from logFC
                            parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));


                            updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)
                            updateBoxPlot1(parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)
                            updateCounter()
                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            console.log(dataN_copy.length)
                        }
                        //   var pc1Values = [];
                        // var pc2Values = [];
                        // var groupValues = [];
                        var req = ocpu.call("pca", {
                            data: data_copy_pval,
                            dataN: dataN_copy_pval,
                            dataC: dataC_copy_pval
                        }, function (session) {
                            var filteredDataURL = session.loc + "/R/.val/json";
                            //console.log(session);
                            // Fetch the filtered data from the URL
                            fetch(filteredDataURL)
                                .then(response => response.json())
                                .then(data => {
                                    json = data
                                    console.log(filteredDataURL)
                                    console.log(json)

                                    var pc1Key = "PC1";
                                    var pc2Key = "PC2";
                                    var groupKey = "Group";

                                    // Arrays to store PC1 and PC2 values


                                    // Iterate over each object in the JSON array
                                    json.scores_df.forEach(function (obj) {
                                        // Push PC1, PC2, and Group values to the arrays
                                        pc1Values.push(obj[pc1Key]);
                                        pc2Values.push(obj[pc2Key]);
                                        groupValues.push(obj[groupKey]);
                                    });
                                    // console.log(pc1Values)

                                    pca_data = [];

                                    // Iterate over each object in the JSON array
                                    json.scores_df.forEach(function (obj) {
                                        // Retrieve additional data from metadata based on _row
                                        var gsm = obj._row;
                                        var group = obj.Group;

                                        // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                        var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                        var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                        var pc1 = obj.PC1;
                                        var pc2 = obj.PC2;

                                        // Create an object with the required fields
                                        var newObj = {
                                            GSM: gsm,
                                            group: group,
                                            smokerclass: smokerclass,
                                            stage: stage,
                                            pc1: pc1,
                                            pc2: pc2
                                        };

                                        // Push the new object to the newData array
                                        pca_data.push(newObj);
                                    });

                                    // Display the newData array
                                    console.log(pca_data);
                                    heatmap_data = []
                                    json.scores_var.forEach(function (obj) {
                                        // Push PC1, PC2, and Group values to the arrays
                                        var gene = obj._row
                                        var pc1 = obj.PC1
                                        var pc2 = obj.PC2
                                        var pc3 = obj.PC3
                                        var pc4 = obj.PC4
                                        var pc5 = obj.PC5
                                        var pc6 = obj.PC6

                                        var newObj = {
                                            gene: gene,
                                            pc1: pc1,
                                            pc2: pc2,
                                            pc3: pc3,
                                            pc4: pc4,
                                            pc5: pc5,
                                            pc6: pc6
                                        };
                                        heatmap_data.push(newObj);
                                    })

                                    pca(pca_data);
                                    heatmap(heatmap_data)
                                })
                        })





                    });
            })



            //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            // console.log("parsed log ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN",dataN_copy.length)

            // const geneCountDiv = document.getElementById('geneCount2');
            // geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

            // Now, dataN, dataC, data, genes, and logFC are updated
        })

        // Assuming newdataNJSON, newdataCJSON, and newdataJSON are your arrays of data
        document.getElementById('thresholdSelect').addEventListener('change', function () {
            //console.log(dataC_copy)
            //console.log(data_copy)
            //console.log(dataN_copy)

            document.getElementById("loadingOverlay").style.display = "block";


            threshold = parseFloat(this.value);

            const ind = old_p_adj.reduce((result, entry, index) => {

                if (entry.pval_adj > threshold) {
                    result.push(index);
                }
                return result;
            }, []);

            updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)


            if (ind.length > 0) {

                //console.log(parsedLogFC.length)

                // Remove entries corresponding to ind from dataN

                // Remove entries corresponding to ind from dataN
                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from logFC
                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                updateCounter()
                updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy, dataC_copy)

                var pc1Values = [];
                var pc2Values = [];
                var groupValues = [];
                var req = ocpu.call("pca", {
                    data: data_copy_pval,
                    dataN: dataN_copy_pval,
                    dataC: dataC_copy_pval
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            json = data
                            console.log(filteredDataURL)
                            console.log(json)

                            var pc1Key = "PC1";
                            var pc2Key = "PC2";
                            var groupKey = "Group";

                            // Arrays to store PC1 and PC2 values


                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                pc1Values.push(obj[pc1Key]);
                                pc2Values.push(obj[pc2Key]);
                                groupValues.push(obj[groupKey]);
                            });
                            // console.log(pc1Values)

                            pca_data = [];

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Retrieve additional data from metadata based on _row
                                var gsm = obj._row;
                                var group = obj.Group;

                                // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                var pc1 = obj.PC1;
                                var pc2 = obj.PC2;

                                // Create an object with the required fields
                                var newObj = {
                                    GSM: gsm,
                                    group: group,
                                    smokerclass: smokerclass,
                                    stage: stage,
                                    pc1: pc1,
                                    pc2: pc2
                                };

                                // Push the new object to the newData array
                                pca_data.push(newObj);

                            });


                            heatmap_data = []
                            json.scores_var.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                var gene = obj._row
                                var pc1 = obj.PC1
                                var pc2 = obj.PC2
                                var pc3 = obj.PC3
                                var pc4 = obj.PC4
                                var pc5 = obj.PC5
                                var pc6 = obj.PC6

                                var newObj = {
                                    gene: gene,
                                    pc1: pc1,
                                    pc2: pc2,
                                    pc3: pc3,
                                    pc4: pc4,
                                    pc5: pc5,
                                    pc6: pc6
                                };
                                heatmap_data.push(newObj);
                            })

                            // Display the newData array
                            console.log(pca_data);


                            pca(pca_data);
                            heatmap(heatmap_data)

                        })





                })

            }

        })

        function pca(pca_data) {
            pc1Values = []
            pc2Values = []
            groupValues = []
            smokerValues = []
            stageValues = []

            // Iterate over the newData array
            pca_data.forEach(function (obj) {
                // Access pc1, pc2, and group values from each object
                var pc1Value = obj.pc1;
                var pc2Value = obj.pc2;
                var groupValue = obj.group;
                var smokerValue = obj.smokerclass;
                var stageValue = obj.stage;
                var gsmValue = obj.GSM; // Assuming GSM is a property in the object

                pc1Values.push(pc1Value);
                pc2Values.push(pc2Value);
                groupValues.push(groupValue);
                smokerValues.push(smokerValue);
                stageValues.push(stageValue);

                // Use the values as needed
                //console.log("PC1:", pc1Value, ", PC2:", pc2Value, ", Group:", groupValue);
            });

            var margin = { top: 20, right: 20, bottom: 50, left: 60 };
            var width = 600;
            var height = 400;

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(pc1Values))
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain(d3.extent(pc2Values))
                .range([height, 0]);

            // Create SVG container
            var svg = d3.select("#pca")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Add circles for each data point
            svg.selectAll(".data-circle")
                .data(pca_data) // Bind data directly to the circles
                .enter().append("circle")
                .attr("class", "data-circle") // Assign the class "data-circle" to the circles
                .attr("cx", function (d) { return xScale(d.pc1); })
                .attr("cy", function (d) { return yScale(d.pc2); })
                .attr("r", 5) // Adjust the radius as needed
                .style("fill", function (d) {
                    // Set different colors based on groups
                    if (d.stage === "Normal") {
                        return "green";
                    } else if (d.stage === "IA") {
                        return "yellow";
                    } else if (d.stage === "IIA") {
                        return "orange";
                    } else if (d.stage === "IIIA") {
                        return "red";
                    } else if (d.stage === "IB") {
                        return "yellow";
                    } else if (d.stage === "IIB") {
                        return "orange";
                    } else if (d.stage === "IIIB") {
                        return "red";
                    } else if (d.stage === "IV") {
                        return "darkred";
                    }
                })
                .attr("stroke", function (d) {
                    // Set stroke color based on presence in gsmList
                    return gsmList.includes(d.GSM) ? "black" : null;
                })
                .attr("stroke-width", function (d) {
                    // Set stroke width based on presence in gsmList
                    return gsmList.includes(d.GSM) ? 2 : null;
                })
                .on("click", function (d) {
                    // On click, select the circle and add the GSM value to the list
                    d3.select(this).attr("stroke", "black").attr("stroke-width", 2);
                    var selectedGSM = d.GSM; // Assuming GSM is a property in the object
                    console.log("Selected GSM:", selectedGSM);
                    gsmList.push(selectedGSM);
                    console.log("GSM List:", gsmList);

                    // Check if the selected GSM is in the transposedData list
                    var selectedData = transposedData.find(function (data) {
                        return data.GSM === selectedGSM;
                    });

                });

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Principal Component Analysis")
                .style("fill", "white");


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("PC1");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("PC2");

            // Define brush function
            var brush = d3.brush()
                .extent([[0, 0], [width, height]])
                .on("end", brushended);

            // Append brush to SVG
            svg.append("g")
                .attr("class", "brush")
                .call(brush);

            // Function to handle brushend event
            function brushended() {
                var selection = d3.event.selection; // Get the brush selection
                var selectedCircles; // Initialize variable to store selected circles

                if (!selection) {
                    // If there's no selection (brush is removed)
                    // Deselect all circles and clear the GSM list
                    selectedCircles = d3.selectAll(".data-circle").each(function () {
                        d3.select(this)
                            .attr("stroke", null) // Remove stroke
                            .attr("stroke-width", null); // Remove stroke width
                    });
                    gsmList = []; // Clear GSM list
                } else {
                    // If there's a selection, proceed as before to handle selected circles
                    selectedCircles = d3.selectAll(".data-circle").filter(function () {
                        var cx = d3.select(this).attr("cx"); // Get the x-coordinate of the circle
                        var cy = d3.select(this).attr("cy"); // Get the y-coordinate of the circle
                        return cx >= selection[0][0] && cx <= selection[1][0] && cy >= selection[0][1] && cy <= selection[1][1];
                    });

                    // Handle selected circles
                    selectedCircles.each(function () {
                        var circle = d3.select(this); // Select the circle
                        var circleGSM = circle.datum().GSM; // Get the GSM value associated with the circle

                        // Add circle's GSM to the list
                        gsmList.push(circleGSM);
                        console.log("Selected GSM:", circleGSM);

                        // Select the circle visually
                        circle.attr("stroke", "black")
                            .attr("stroke-width", 2);

                    });
                }

                // Update parallel plot or any other function with the updated GSM list
                updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);


                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)




            }


        }

        function updateHistogram(variation_data) {
            // Filter data based on the threshold
            const filteredData = variation_data.filter(variation => variation >= thr_prc);

            // Create histogram using D3.js
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            const svg = d3.select("#IQR")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram
            const histogram = d3.histogram()
                .value(variation => variation)
                .domain(d3.extent(variation_data))
                .thresholds(100);

            const bins = histogram(variation_data);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(variation_data))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", d => {
                    const thresholdPosition = xScale(thr_prc);
                    if (xScale(d.x1) < thresholdPosition) {
                        return "grey"; // Set the color to grey if d.x1 is less than the threshold
                    } else {
                        return "darkgreen"; // Set the original bar color
                    }
                });

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(thr_prc);
                    return xScale(d.x0); // Start the overlay from the beginning of the bar
                })
                .attr("y", d => yScale(d.length))
                .attr("width", d => {
                    const thresholdPosition = xScale(thr_prc);
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                        // Calculate the width of the portion to color
                        return thresholdPosition - xScale(d.x0); // Only color the left portion
                    } else {
                        return 0; // Set width to 0 for bars where threshold is not in range
                    }
                })
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "grey") // Color the left portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("IQR value");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");


            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("IQR Frequency distribution");

            // Add a red line indicating the threshold
            const thresholdLine = svg.append("line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);

            // Update the position of the threshold line
            thresholdLine.attr("x1", xScale(thr_prc))
                .attr("x2", xScale(thr_prc));


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "darkgreen");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");


        }

        function updateLogFCHistogram(logFCData) {
            // Extract logFC values and convert them to numbers
            const logFCValues = logFCData.map(entry => entry.logFC);

            // Define histogram parameters
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            // Create SVG container
            const svg = d3.select("#logFCHistogram")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram using D3.js
            const histogram = d3.histogram()
                .value(d => d)
                .domain(d3.extent(logFCValues))
                .thresholds(100); // Number of bins

            const bins = histogram(logFCValues);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(logFCValues))
                .nice()
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .nice()
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "orange");

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
            xAxis.selectAll("line, path")
                .style("stroke", "white");
            xAxis.selectAll("text")
                .style("fill", "white");
            // .append("text")
            // .attr("x", width / 2)
            // .attr("y", margin.bottom * 0.8)
            // .attr("text-anchor", "middle")
            // .text("logFC");


            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))
            // .append("text")
            // .attr("transform", "rotate(-90)")
            // .attr("y", -margin.left * 0.7)
            // .attr("x", -height / 2)
            // .attr("text-anchor", "middle")
            // .text("frequency");

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Log fold change");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");



            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("FC (logarithmic) frequency distribution");

            // Add ablines
            svg.append("line")
                .attr("x1", xScale(-Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(-Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            svg.append("line")
                .attr("x1", xScale(Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
                })
                .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
                .attr("width", d => {
                    const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    // Calculate the width of the portion to color
                    return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
                })
                .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
                .attr("fill", "grey") // Color the portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "orange");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");



        }

        function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            //console.log(parsed)

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;



            // Set up margin, width, and height
            var margin = { top: 10, right: 100, bottom: 40, left: 60 };
            var width = 1000 - margin.left - margin.right;
            var height = 600 - margin.top - margin.bottom;

            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsN)))
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsC)))
                .range([height, 0])
                .nice()


            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");
            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Customization

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Normal))</tspan>");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Case))</tspan>")
                .style("fill", "white");

            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatterplot")
                .style("fill", "white");

            // // Add X axis
            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(xScale));

            // // Add Y axis
            // svg.append("g")
            //     .call(d3.axisLeft(yScale));

            // Create circles for each gene
            var data = Object.keys(averageExpressions10N).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressions10N[gene], Case: averageExpressions10C[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 80) + "," + (height - 250) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)
                .attr("y", 5)
                .attr("width", 140)
                .attr("height", 180)
                .style("stroke", "white")
                .style("fill", "none")
                .style("filter", "url(#legendShadow)");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 3)
                .style("fill", "darkred");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "white")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 12) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .text("LogFC > log2(" + thr_fc + ") and");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 44)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(0," + legendItemHeight + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 3)
                .style("fill", "royalblue");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 40)
                .style("fill", "white")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 12) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .text("LogFC < -log2(" + thr_fc + ") and");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 64)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(0," + 2 * legendItemHeight + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 65)
                .attr("r", 3)
                .style("fill", "grey");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 12) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .text("|LogFC| < log2(" + thr_fc + ") or");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 94)
                .style("fill", "white")
                .text("pval_adj > " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => xScale(d.Normal))
                .attr("cy", d => yScale(d.Case))
                .attr("r", d => {
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "4"
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                        return "4"
                    }
                })
                .style("fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                        return "royalblue";
                    }
                    else {
                        return "grey";
                    }
                })
                .attr("data-initial-fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        currentCircleFill = "darkred"
                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        currentCircleFill = "royalblue"
                        return "royalblue";
                    }
                }

                )
                .classed('pulse', d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    } else {
                        return false;
                    }

                })
                .on("mouseover", function (d) {
                    // Highlight the gene on mouseover
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    // Display tooltip on mouseover
                    tooltip.transition()
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with grey
                    if (currentFill === "grey") {
                        return; // If grey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedElement.style("fill") === "green";

                    if (isHighlighted) {
                        console.log("sono verde")
                        // If already highlighted, remove the highlighting
                        selectedElement.style("fill", d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else {
                                return "grey";
                            }

                        })
                            .classed('pulse', false)
                            .classed("pulse1", false);
                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        // Find and remove the corresponding option from the select element
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }

                        updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    } else {
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("fill", "green")
                            .style("stroke-width", 2)
                            .classed('pulse', true)
                            .classed('pulse1', false)
                        //.attr("data-initial-fill","green")    
                        // Find the corresponding scatterplot circle and toggle its selection


                        var correspondingSquare = square
                            .filter(function (squaredata) {
                                return squaredata.gene === d.gene;
                            });
                        console.log(correspondingSquare)
                        correspondingSquare.style("stroke", "none")

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        var select = document.getElementById("selectButton");

                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                        synchronizeAnimations(this);

                        // Call a function to create parallel coordinates plot using selectedGeneData
                        updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    }
                });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }

            function updateChart() {
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");

                yAxis.selectAll("line, path")
                    .style("stroke", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return newX(d.Normal); })
                    .attr('cy', function (d) { return newY(d.Case); });
            }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }
        }

        function formatPValue(pval) {
            // Check if the p-value is too small to be displayed without scientific notation
            if (pval < 0.01) {
                // Use toExponential to format the p-value in scientific notation with two decimal places
                return pval.toExponential(3);
            } else {
                // Otherwise, use toFixed to format the p-value with two decimal places
                return pval.toFixed(2);
            }
        }


        let last_box = ""

        function updateBoxPlot(genename, parsedLogFC, dataN, dataC) {

            if (combinedData.length == 0) {
                last_box = genename
                geneNameUP = genename;


                var geneDataN = dataN.filter(d => d.gene === geneNameUP)
                var geneDataC = dataC.filter(d => d.gene === geneNameUP)



                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));


                function computeBoxPlotStatistics(data1) {
                    var expressionValues = data1.map(entry => entry.expression);

                    // Sort the data for calculating quartiles
                    expressionValues.sort((a, b) => a - b);

                    // Calculate quartiles and median
                    var q1 = d3.quantile(expressionValues, 0.25);
                    var q3 = d3.quantile(expressionValues, 0.75);
                    var median = d3.median(expressionValues);

                    // Calculate interquartile range (IQR)
                    var iqr = q3 - q1;


                    var min = q1 - 1.5 * iqr
                    var max = q3 + 1.5 * iqr

                    return {
                        q1: q1,
                        median: median,
                        q3: q3,
                        iqr: iqr,
                        min: min,
                        max: max
                    };
                }

                let expressionValuesC
                geneDataC.forEach(entry => {
                    expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })

                //console.log(expressionValuesC)

                let expressionValuesN
                geneDataN.forEach(entry => {
                    expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })
                // Assuming you have expressionValuesC and expressionValuesN

                // Create a new array to store the combined data
                //combinedData;

                // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case' });
                });

                // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal' });
                });

                console.log(combinedData)

                var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                sumstat = d3.nest()
                    .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                    .rollup(function (d) {
                        q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                        median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                        q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                        interQuantileRange = q3 - q1;
                        min = q1 - 1.5 * interQuantileRange;
                        max = q3 + 1.5 * interQuantileRange;

                        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                    })
                    .entries(combinedData);

                var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                    width = 500,
                    height = 330;


                var svg = d3.select("#boxPlot")
                    .html("")  // Clear previous content
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(["Normal", "Case"])
                    .paddingInner(1)
                    .paddingOuter(.5)

                var xAxis = svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))
                xAxis.selectAll("line, path")
                    .style("stroke", "white");
                xAxis.selectAll("text")
                    .style("fill", "white");

                var y = d3.scaleLinear()
                    .domain([boxPlotStatisticsC.min - 4, boxPlotStatisticsC.max + 4])
                    .range([height, 0])

                var yAxisGroup = svg.append("g")
                    .attr("class", "y-axis") // Assign a class to the group element
                    .call(d3.axisLeft(y));

                // Append the y-axis label
                yAxisGroup.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -40)  // Adjust the position as needed
                    .attr("x", -height / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("fill", "white")
                    .style("font-size", "14px")
                    .html("log<tspan dy='5'>2</tspan> <tspan dy ='-5'>(Expression)");


                // You can further customize the appearance of the axis elements if needed
                yAxisGroup.selectAll("line, path")
                    .style("stroke", "white");

                yAxisGroup.selectAll("text")
                    .style("fill", "white");

                // Add a title
                var title = svg.append("text")
                    .attr("class", "title")
                    .attr("x", width / 2)
                    .attr("y", margin.top)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .text("Gene " + geneNameUP)
                    .style("fill", "white");

                svg.selectAll(".vertLines")
                    .data(sumstat)
                    .transition()
                    .duration(1000)

                var line1 = svg
                    .selectAll(".vertLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "vertLines")
                    .attr("x1", function (d) { return (x(d.key)) })
                    .attr("x2", function (d) { return (x(d.key)) })
                    .attr("y1", function (d) { return (y(d.value.min)) })
                    .attr("y2", function (d) { return (y(d.value.max)) })
                    .attr("stroke", "black")
                    .style("width", 40)


                // rectangle for the main box
                var boxWidth = 100
                var box1 = svg
                    .selectAll(".boxes")
                    .data(sumstat)
                    .enter()
                    .append("rect")
                    .attr("class", "boxes")
                    .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("y", function (d) { return (y(d.value.q3)) })
                    .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                    .attr("width", boxWidth)
                    .attr("stroke", "black")
                    .style("fill", function (d) {
                        if (d.key === "Case") {
                            return "#a05853"
                        }
                        else {
                            return "#118e91"
                        }
                    })
                var line2 = svg
                    .selectAll(".medianLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "medianLines")
                    .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                    .attr("y1", function (d) { return (y(d.value.median)) })
                    .attr("y2", function (d) { return (y(d.value.median)) })
                    .attr("stroke", "black")
                    .style("width", 80)

                var jitterWidth = 50
                var jitter = svg
                    .selectAll(".indPoints")
                    .data(combinedData)
                    .enter()
                    .append("circle")
                    .attr("class", function (d) {
                        // Add the pulse-red class if the GSM is in the gsmList
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                    .attr("cx", function (d) { return (x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth) })
                    .attr("cy", function (d) { return (y(d.expression)) })
                    .attr("r", 2)
                    .style("fill", "white")
                    .attr("stroke", function (d) {

                        return gsmList.includes(d.GSM) ? "black" : "black";

                    })
                    .attr("stroke-width", function (d) {
                        // Set stroke width based on presence in gsmList
                        return gsmList.includes(d.GSM) ? 3 : 1;
                    })
                    .on("click", function (d) {
                        // On click, select the circle and add the GSM value to the list
                        var selectedGSM = d.GSM;
                        var isSelected = gsmList.includes(selectedGSM);
                        // console.log(isSelected);

                        // Toggle selection state
                        if (!isSelected) {
                            gsmList.push(selectedGSM);
                        } else {
                            gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                        }

                        // Update class, stroke, and stroke-width
                        d3.select(this)
                            .classed("pulse-red", !isSelected)
                            .attr("stroke", isSelected ? "black" : "black")
                            .attr("stroke-width", isSelected ? 1 : 2);

                        // Call necessary update functions
                        updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                        pca(pca_data);


                    });

            } else {

                if (genename !== last_box) {
                    last_box = genename
                    combinedData = []
                    geneNameUP = genename;


                    var geneDataN = dataN.filter(d => d.gene === geneNameUP)
                    var geneDataC = dataC.filter(d => d.gene === geneNameUP)



                    // Extract GSM values for each gene
                    var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                    var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));


                    function computeBoxPlotStatistics(data1) {
                        var expressionValues = data1.map(entry => entry.expression);

                        // Sort the data for calculating quartiles
                        expressionValues.sort((a, b) => a - b);

                        // Calculate quartiles and median
                        var q1 = d3.quantile(expressionValues, 0.25);
                        var q3 = d3.quantile(expressionValues, 0.75);
                        var median = d3.median(expressionValues);

                        // Calculate interquartile range (IQR)
                        var iqr = q3 - q1;


                        var min = q1 - 1.5 * iqr
                        var max = q3 + 1.5 * iqr

                        return {
                            q1: q1,
                            median: median,
                            q3: q3,
                            iqr: iqr,
                            min: min,
                            max: max
                        };
                    }

                    let expressionValuesC
                    geneDataC.forEach(entry => {
                        expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })

                    //console.log(expressionValuesC)

                    let expressionValuesN
                    geneDataN.forEach(entry => {
                        expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })
                    // Assuming you have expressionValuesC and expressionValuesN

                    // Create a new array to store the combined data
                    //combinedData;

                    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                    expressionValuesC.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case' });
                    });

                    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                    expressionValuesN.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal' });
                    });

                    console.log(combinedData)

                    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                    sumstat = d3.nest()
                        .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                        .rollup(function (d) {
                            q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                            median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                            q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                            interQuantileRange = q3 - q1;
                            min = q1 - 1.5 * interQuantileRange;
                            max = q3 + 1.5 * interQuantileRange;

                            return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                        })
                        .entries(combinedData);
                    var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                        width = 500,
                        height = 330;


                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");

                    var x = d3.scaleBand()
                        .range([0, width])
                        .domain(["Normal", "Case"])
                        .paddingInner(1)
                        .paddingOuter(.5)

                    var y = d3.scaleLinear()
                        .domain([boxPlotStatisticsC.min - 4, boxPlotStatisticsC.max + 4])
                        .range([height, 0])

                    // Update y-axis
                    svg.select(".y-axis")
                        .transition()
                        .duration(1000)
                        .call(d3.axisLeft(y));

                    // Update axis styles
                    svg.selectAll(".y-axis line, .y-axis path")
                        .style("stroke", "white");

                    svg.selectAll(".y-axis text")
                        .style("fill", "white");


                    // Select the existing title element
                    var title = svg.select(".title");

                    // Update the title text and transition its position
                    title.text("Gene " + geneNameUP)
                        .transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    var line1 = svg.selectAll(".vertLines")
                        .data(sumstat);

                    // Remove old lines
                    line1.exit().remove();

                    // Update existing lines
                    line1.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    // Append new lines
                    line1.enter()
                        .append("line")
                        .attr("class", "vertLines")
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    boxWidth = 100

                    // Define the initial position and size of the boxes
                    var box1 = svg.selectAll(".boxes")
                        .data(sumstat);

                    // Remove old boxes
                    box1.exit().remove();

                    // Update existing boxes
                    box1.transition()
                        .duration(1000)
                        .attr("x", function (d) {
                            return x(d.key) - boxWidth / 2;
                        })
                        .attr("y", function (d) {
                            return y(d.value.q3);
                        })
                        .attr("height", function (d) {
                            return y(d.value.q1) - y(d.value.q3);
                        })
                        .attr("width", boxWidth) // Keep width constant
                        .style("fill", function (d) {
                            return d.key === "Case" ? "#a05853" : "#118e91";
                        });

                    // Append new boxes and smoothly transition them to their new positions
                    box1.enter()
                        .append("rect")
                        .attr("class", "boxes")
                        .attr("stroke", "black")
                        .style("fill", function (d) {
                            return d.key === "Case" ? "#a05853" : "#118e91";
                        })
                        .attr("x", function (d) { return x(d.key) - boxWidth / 2; }) // Set initial position
                        .attr("y", function (d) { return y(d.value.q3); }) // Set initial position
                        .attr("height", 0) // Set initial height to 0
                        .attr("width", boxWidth) // Keep width constant
                        .transition() // Transition to new position and size
                        .duration(1000)
                        .attr("y", function (d) { return y(d.value.q3); }) // Transition to new y position
                        .attr("height", function (d) { return y(d.value.q1) - y(d.value.q3); }); // Transition to new height

                    // Select existing median lines and smoothly update them
                    var medianLines = svg.selectAll(".medianLines")
                        .data(sumstat);

                    // Remove old median lines
                    medianLines.exit().remove();

                    // Update existing median lines
                    medianLines.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Append new median lines
                    medianLines.enter()
                        .append("line")
                        .attr("class", "medianLines")
                        .attr("stroke", "black")
                        .style("width", 80)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Select the existing title or append a new one if it doesn't exist
                    var title = svg.selectAll(".title")
                        .data([0]); // Use dummy data to ensure only one title is selected or appended

                    // Update existing title text
                    title.text("Gene " + geneNameUP);

                    // Append new title if it doesn't exist
                    title.enter()
                        .append("text")
                        .attr("class", "title")
                        .attr("x", width / 2)
                        .attr("y", margin.top)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("fill", "white")
                        .text("Gene " + geneNameUP);

                    // Smoothly transition the title position
                    title.transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    // Update jitter points
                    var jitterWidth = 50;
                    var jitter = svg.selectAll(".indPoints")
                        .data(combinedData);

                    jitter.enter()
                        .append("circle")
                        .attr("class", ".indPoints")
                        .attr("stroke", "black")
                        .style("fill", "white")
                        .attr("r", 2)
                        .merge(jitter)
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) { console.log("circle"); return x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth; })
                        .attr("cy", function (d) { return y(d.expression); });

                    jitter.exit().remove();

                } else {

                    console.log("Sono update box, gene ricevuto " + genename)

                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");


                    var jitterWidth = 50
                    // Define the update selection for the jitter circles
                    var jitterUpdate = svg.selectAll(".indPoints")
                        .data(combinedData);

                    // Update the class, stroke, and stroke width based on the GSM list
                    jitterUpdate.attr("class", function (d) {
                        // console.log(gsmList.includes(d.GSM));
                        if (gsmList.includes(d.GSM)) {
                            // this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                        }
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                        .attr("stroke", function (d) {
                            return gsmList.includes(d.GSM) ? "black" : "black";
                        })
                        .attr("stroke-width", function (d) {
                            return gsmList.includes(d.GSM) ? 3 : 1;
                        })
                        .on("click", function (d) {
                            var selectedGSM = d.GSM;
                            var isSelected = gsmList.includes(selectedGSM);
                            // console.log(isSelected);

                            // Toggle selection state
                            if (!isSelected) {
                                gsmList.push(selectedGSM);
                            } else {
                                gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                            }

                            // Update class, stroke, and stroke-width
                            d3.select(this)
                                .classed("pulse-red", !isSelected)
                                .attr("stroke", isSelected ? "black" : "black")
                                .attr("stroke-width", isSelected ? 1 : 2);

                            // Call necessary update functions
                            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                            pca(pca_data);
                        });

                    // Enter selection: No need to append new circles, as we're only updating existing ones

                    // Remove old circles
                    jitterUpdate.exit().remove();
                }
            }
            d3.select("#selectButton").on("change", function (d) {

                // recover the option that has been chosen
                var selectedOption = d3.select(this).property("value")
                console.log(selectedOption)
                // if(selectedOption == "MostUp"){
                //     first_box = true
                // }
                // else{
                //     first_box = false
                // }
                // // run the updateChart function with this selected option
                updateBoxPlot(selectedOption, parsedLogFC, dataN, dataC)
            })



        }


        function updateBoxPlot1(parsedLogFC, dataN, dataC) {


            combinedData1 = []
            var mostDownregulatedGene = parsedLogFC.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsedLogFC[0]);

            //console.log(mostUpregulatedGene)
            geneNameDown = mostDownregulatedGene.Gene;



            var geneDataN = dataN.filter(d => d.gene === geneNameDown)
            var geneDataC = dataC.filter(d => d.gene === geneNameDown)

            // Extract GSM values for each gene
            var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
            var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));


            //  console.log(geneDataC)  
            //  console.log(geneDataC)

            function computeBoxPlotStatistics(data1) {
                var expressionValues = data1.map(entry => entry.expression);

                // Sort the data for calculating quartiles
                expressionValues.sort((a, b) => a - b);

                // Calculate quartiles and median
                var q1 = d3.quantile(expressionValues, 0.25);
                var q3 = d3.quantile(expressionValues, 0.75);
                var median = d3.median(expressionValues);

                // Calculate interquartile range (IQR)
                var iqr = q3 - q1;


                var min = q1 - 1.5 * iqr
                var max = q3 + 1.5 * iqr

                return {
                    q1: q1,
                    median: median,
                    q3: q3,
                    iqr: iqr,
                    min: min,
                    max: max
                };
            }
            let expressionValuesC
            geneDataC.forEach(entry => {
                expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

            })
            let expressionValuesN
            geneDataN.forEach(entry => {
                expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

            })
            // Assuming you have expressionValuesC and expressionValuesN

            // Create a new array to store the combined data
            //

            // Iterate over expressionValuesC and add objects to combinedData with type 'case'
            expressionValuesC.forEach((expression, i) => {
                combinedData1.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case' });
            });

            // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
            expressionValuesN.forEach((expression, i) => {
                combinedData1.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal' });
            });

            // Now combinedData has the desired structure
            //console.log(combinedData);



            var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData1);


            sumstat1 = d3.nest()
                .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                .rollup(function (d) {
                    q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                    median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                    q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                    interQuantileRange = q3 - q1;
                    min = q1 - 1.5 * interQuantileRange;
                    max = q3 + 1.5 * interQuantileRange;

                    return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                })
                .entries(combinedData1);

            var margin = { top: 10, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;


            var svg = d3.select("#boxPlot1")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            var x = d3.scaleBand()
                .range([0, width])
                .domain(["Normal", "Case"])
                .paddingInner(1)
                .paddingOuter(.5)

            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x))

            var y = d3.scaleLinear()
                .domain([boxPlotStatisticsC.min - 4, boxPlotStatisticsC.max + 4])
                .range([height, 0])
            svg.append("g").call(d3.axisLeft(y))

            // Add a title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", margin.top)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("The Most Downregulated Gene " + geneNameDown);


            svg
                .selectAll("vertLines")
                .data(sumstat1)
                .enter()
                .append("line")
                .attr("x1", function (d) { return (x(d.key)) })
                .attr("x2", function (d) { return (x(d.key)) })
                .attr("y1", function (d) { return (y(d.value.min)) })
                .attr("y2", function (d) { return (y(d.value.max)) })
                .attr("stroke", "black")
                .style("width", 40)

            // rectangle for the main box
            var boxWidth = 100
            svg
                .selectAll("boxes")
                .data(sumstat1)
                .enter()
                .append("rect")
                .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                .attr("y", function (d) { return (y(d.value.q3)) })
                .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                .attr("width", boxWidth)
                .attr("stroke", "black")
                .style("fill", "#69b3a2")

            svg
                .selectAll("medianLines")
                .data(sumstat1)
                .enter()
                .append("line")
                .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                .attr("y1", function (d) { return (y(d.value.median)) })
                .attr("y2", function (d) { return (y(d.value.median)) })
                .attr("stroke", "black")
                .style("width", 80)

            var jitterWidth = 50
            svg
                .selectAll(".indPoints")
                .data(combinedData1)
                .enter()
                .append("circle")
                .attr("cx", function (d) { return (x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth) })
                .attr("cy", function (d) { return (y(d.expression)) })
                .attr("r", 2)
                .style("fill", "white")
                .attr("stroke", "black")
        }


        function updateParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {
            let structureCombinedData = [];

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case', index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal', index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            //console.log(structureCombinedData);

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallelcoordinates")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            //var selectedVariable = document.querySelector('input[name="variable"]:checked').value;


            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "Case"])
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Smoker") {
                color = d3.scaleOrdinal()
                    .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                    .range(["#0d0887", "#bd3786", "#fddb6d"]);
            } else if (selectedVariable === "Gender") {
                color = d3.scaleOrdinal()
                    .domain(["Male", "Female"]) // Set the domain based on the age data
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Stage") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                    .range(["#0d0887", "#46039f", "#7201a8", "#9c179e", "#bd3786", "#d8576b", "#ed7953", "#fddb6d"]);
            }

            var ageAtDiagnosisValues = metadata['Age at Diagnosis:ch1'];

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var y = {};
            for (var i in dimensions) {
                var name = dimensions[i];
                y[name] = d3.scaleLinear()
                    .domain([0, 20])
                    .range([height, 0]);
            }
            // Extract age data from metadata
            var ageData = metadata["Age at Diagnosis:ch1"];
            var genderData = metadata["Gender:ch1"];
            var smokerData = metadata["Cigarette Smoking Status:ch1"];
            var stageData = metadata["Stage:ch1"];

            // Convert age data to numbers
            ageData = ageData.map(function (age) {
                return parseFloat(age);
            });

            // Determine the age domain
            var ageDomain = d3.extent(ageData);

            // Update the y-scale for the age dimension
            y["Age at Diagnosis"] = d3.scaleLinear()
                .domain([30, 90]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for the age dimension
            y["Gender"] = d3.scaleOrdinal()
                .domain(["Male", "Female"]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for Cigarette Smoking Status
            y["Smoking Status"] = d3.scaleOrdinal()
                .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                .range([height, height / 2, 0])

            var interval = height / 7;

            y["Stage"] = d3.scaleOrdinal()
                .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                .range([height, height - interval, height - 2 * interval, height - 3 * interval, height - 4 * interval, height - 5 * interval, height - 6 * interval, 0]);

            // Update the y-scale for type
            y["type"] = d3.scaleOrdinal()
                .domain(["Normal", "Case"])
                .range([height, 0])


            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            //console.log(metadata)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(color);

            // Append legend to the SVG
            legend.call(legendColor);

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "white") // Set label color to white
                .style("font-size", "14px")  // Adjust font size

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            // Transpose the structureCombinedData
            transposedData = [];
            if (geneselected.length > 0) {
                // Use geneselected when it's not empty
                geneselected.forEach(function (geneName) {
                    var geneData = structureCombinedData.find(d => d.gene === geneName);
                    geneData.expressions.forEach(function (expression, i) {
                        if (!transposedData[i]) transposedData[i] = { GSM: expression.GSM }; // Use GSM value from expression
                        transposedData[i][geneName] = expression.expression;
                        transposedData[i].type = expression.type; // Add the type property to each observation
                        // Find the index of the GSM in the metadata's geo_accession array
                        var gsmIndex = metadata.geo_accession.findIndex(item => item === expression.GSM);
                        if (gsmIndex !== -1) {
                            // If the GSM is found in metadata, insert the corresponding Age at Diagnosis
                            transposedData[i]['Age at Diagnosis'] = metadata['Age at Diagnosis:ch1'][gsmIndex];
                            transposedData[i]['Gender'] = metadata['Gender:ch1'][gsmIndex];
                            transposedData[i]['Smoking Status'] = metadata['Cigarette Smoking Status:ch1'][gsmIndex];
                            transposedData[i]['Stage'] = metadata['Stage:ch1'][gsmIndex];
                        }
                    });
                });
            } else {
                // Use first_dims when geneselected is empty
                transposedData = metadata.geo_accession.map((gsm, i) => ({
                    GSM: gsm,
                    'Age at Diagnosis': metadata['Age at Diagnosis:ch1'][i],
                    'Gender': metadata['Gender:ch1'][i],
                    'Smoking Status': metadata['Cigarette Smoking Status:ch1'][i],
                    'Stage': metadata['Stage:ch1'][i],
                    type: metadata['Stage:ch1'][i] === "Normal" ? "Normal" : "Case"
                }));
            }
            //console.log(transposedData);
            // Select all paths with the class "gsm-path"
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(transposedData)
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d.GSM) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    var pathString = path(d);
                    return pathString;
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    if (selectedVariable === "case") {
                        return color(d.type);
                    } else if (selectedVariable === "Smoker") {
                        return color(d['Smoking Status']);
                    } else if (selectedVariable === "Gender") {
                        return color(d['Gender']);
                    } else if (selectedVariable === "Stage") {
                        return color(d['Stage']);
                    }
                })

            gsmPaths.on("click", function (d) {
                var clickedGSM = d.GSM; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));
                pca(pca_data)

                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)



                console.log("GSM List:", gsmList);
            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }
            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum().GSM;
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });


            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                });

            axis.append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axis.selectAll(".domain")
                .attr("stroke", "white");

            axis.selectAll(".tick text")
                .style("fill", "white");
            axis.selectAll(".tick line")
                .attr("stroke", "white");


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                })
                .call(drag); // Apply drag behavior to each axis group;

            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axisGroups.selectAll(".domain")
                .attr("stroke", "white");

            axisGroups.selectAll(".tick text")
                .style("fill", "white");
            axisGroups.selectAll(".tick line")
                .attr("stroke", "white");



            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).raise().classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                transposedData = transposedData.filter(function (d) {
                    return !removedDimensions.includes(d.gene);
                });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }


                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                updateParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin, old_p_adj)
                d3.selectAll(".axis-label").classed("dragging", false);

            }
            var newPositions = [];
            svg.selectAll(".axis-group").each(function (d) {
                var transform = d3.select(this).attr("transform");
                var translateX = +transform.split("(")[1].split(")")[0];
                console.log(translateX)
                newPositions.push({ dimension: d, position: translateX });
            });
            console.log(newPositions)

            // Sort newPositions array based on position
            newPositions.sort(function (a, b) {
                return a.position - b.position;
            });

            // Separate dimensions into geneselected, metadata (first_dims), and total ordering
            var geneselectedOrder = [];
            var metadataOrder = [];
            totalOrder = [];
            newPositions.forEach(function (d) {
                if (geneselected.includes(d.dimension)) {
                    geneselectedOrder.push(d.dimension);
                } else if (first_dims.includes(d.dimension)) {
                    metadataOrder.push(d.dimension);
                }
                totalOrder.push(d.dimension);
            });

            // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
            var removedDimensions = [];
            newPositions.forEach(function (d) {
                if (d.position < -100 && geneselected.includes(d.dimension)) {
                    var index = geneselectedOrder.indexOf(d.dimension);
                    if (index !== -1) {
                        removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                        // Remove highlighting color in the scatter plot
                        scatter.selectAll("circle")
                            .filter(circleData => circleData.gene === d.dimension)
                            .style("fill", d => {
                                // Check if logFC is greater than or equal to the threshold
                                if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                    return "darkred";
                                } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                    return "royalblue";
                                } else {
                                    return "grey";
                                }
                            });
                    }
                }
            });

            // Remove corresponding data from transposedData
            transposedData = transposedData.filter(function (d) {
                return !removedDimensions.includes(d.gene);
            });

            // Update totalOrder by removing removedDimensions
            totalOrder = totalOrder.filter(function (d) {
                return !removedDimensions.includes(d);
            });

            console.log("Geneselected order:", geneselectedOrder);
            console.log("Metadata order:", metadataOrder);
            console.log("Total order:", totalOrder);
            console.log("Removed dimensions:", removedDimensions);

            selectedGeneData = geneselectedOrder


            first_dims = metadataOrder

            ordering = totalOrder
            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg;
                if (selectedVariable === "case") {
                    selected_reg = d.type;
                } else if (selectedVariable === "Smoker") {
                    selected_reg = d['Smoking Status'];
                } else if (selectedVariable === "Gender") {
                    selected_reg = d['Gender'];
                } else if (selectedVariable === "Stage") {
                    selected_reg = d['Stage']; // Set default value
                }

                // First, every group turns grey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? color(selected_reg) : "lightgrey";
                        }
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? "1" : "0.2";
                        }
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front

            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Set stroke color based on the selected variable
                        if (selectedVariable === "case") {
                            return color(data.type);
                        } else if (selectedVariable === "Smoker") {
                            return color(data['Smoking Status']);
                        } else if (selectedVariable === "Gender") {
                            return color(data['Gender']);
                        } else if (selectedVariable === "Stage") {
                            return color(data['Stage']);
                        }
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data.GSM);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }

        function heatmap(heatmap_data) {
            var heatmap_data_subset = heatmap_data.slice(0, 6);
            console.log(heatmap_data_subset)
            // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
            var myGroups = heatmap_data_subset.map(d => d.gene);
            var myVars = Object.keys(heatmap_data_subset[0]).filter(d => d !== "gene");
            // set the dimensions and margins of the graph

            var margin = { top: 40, right: 75, bottom: 30, left: 100 },
                width = 600 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#heatmap")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + (margin.left + 46) + "," + margin.top + ")");

            // Build X scales and axis:
            var x = d3.scaleBand()
                .range([0, width])
                .domain(myVars)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 15)
                .attr("transform", "translate(0,0)")
                .call(d3.axisTop(x).tickSize(0))
                .select(".domain").remove();

            // Add click event listener to the X-axis tick texts
            svg.selectAll(".tick text")
                .style("fill", "white")
                .style("text-transform", "uppercase")

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([0, height])
                .domain(myGroups)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 15)
                .style("fill", "white")
                .call(d3.axisLeft(y).tickSize(0))
                .select(".domain").remove();

            // Select and style the tick text for the Y axis
            svg.selectAll(".tick text").style("fill", "white");

            // Add title text
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -25)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Heatmap")
                .style("fill", "white");
            // Build color scale
            var myColor = d3.scaleSequential()
                .interpolator(d3.interpolateInferno)
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))]);

            // create a tooltip
            var tooltip = d3.select("#heatmap")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px");

            // Three functions that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                tooltip
                    .style("opacity", 1);

                if (d3.select(this).style("stroke") === "none") {
                    d3.select(this)
                        .style("stroke", "yellow")
                        .style("opacity", 1);
                }

            };

            var mousemove = function (d) {
                var valueString;
                if (d.value < 0.01) {
                    valueString = d.value.toExponential(2) + "%";
                } else {
                    valueString = (d.value).toFixed(2) + "%";
                }
                // Calculate the position of the tooltip
                var xPosition = d3.event.pageX + 10; // 10 pixels to the right of the mouse pointer
                var yPosition = d3.event.pageY - 10; // 10 pixels above the mouse pointer
                tooltip
                    .html("The exact value of<br>this cell is: " + valueString)
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px");
            };

            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                    .style("pointer-events", "none"); // Disable pointer events for the tooltip

                if (d3.select(this).style("stroke") === "yellow") {

                    d3.select(this).style("stroke", "none")
                        .style("opacity", 0.8)

                }


            };

            // add the squares
            square = svg.selectAll(".heatmap-rect")
                .data(heatmap_data_subset.flatMap(d => myVars.map(v => ({ gene: d.gene, variable: v, value: d[v] }))))
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.variable); })
                .attr("y", function (d) { return y(d.gene); })
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.value); })
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", 0.8)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseleave)
                .on("click", function (d) {
                    var selectedElement = d3.select(this);

                    // Check if the rectangle is already stroked
                    var isRectangleStroked = selectedElement.style("stroke") === "red";

                    // Find the corresponding scatterplot circle and toggle its selection
                    var correspondingCircle = scatter.selectAll("circle")
                        .filter(function (circleData) {
                            return circleData.gene === d.gene;
                        });

                    // Store the selected rectangle's variable
                    var selectedVariable = d.variable;

                    svg.selectAll("rect")
                        .filter(function (rectData) {
                            return rectData.gene === d.gene;
                        })
                        .style("stroke", function (rectData) {
                            // Remove stroke only from rectangles that are not selected
                            return rectData.variable === selectedVariable ? "red" : "none";
                        });

                    // If the rectangle is already stroked, remove the stroke and revert circle's fill color
                    if (isRectangleStroked) {
                        var initialCircleFill = correspondingCircle.attr("data-initial-fill"); // Retrieve the initial fill color
                        selectedElement.style("stroke", "none");
                        correspondingCircle.style("fill", initialCircleFill)
                            .classed("pulse1", false)
                    } else {
                        // If the rectangle is not stroked, toggle the stroke and set circle's fill color
                        currentCircleFill = correspondingCircle.attr("data-initial-fill");
                        console.log(correspondingCircle)
                        console.log(currentCircleFill)
                        correspondingCircle.attr("data-initial-fill", currentCircleFill); // Save the initial fill color
                        selectedElement.style("stroke", "red");
                        correspondingCircle.style("fill", myColor(d.value)).classed("pulse1", true);
                        console.log(correspondingCircle)
                        synchronizeAnimations(correspondingCircle.node())
                    }
                });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation1');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            document.getElementById("loadingOverlay").style.display = "none";
        }

        function calculateAverageExpressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Add the expression value to the sum and increment the count
                        geneSumCount[gene].sum += parseFloat(geneData[sample]);
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average for each gene
            var averageExpressions = {};
            for (var gene in geneSumCount) {
                averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageExpressions;
        }

        function calculateAverageLog10Expressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Apply Math.log10 to the expression value before summing
                        var log10Expression = Math.log2(parseFloat(geneData[sample]));

                        // Add the log10 expression value to the sum and increment the count
                        geneSumCount[gene].sum += log10Expression;
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average log10 expression for each gene
            var averageLog10Expressions = {};
            for (var gene in geneSumCount) {
                averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageLog10Expressions;
        }

        // Function to handle checkbox change event
        function handleCheckboxChange() {
            var checkbox = document.getElementById("vehicle1");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Age at Diagnosis');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Age at Diagnosis');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeGender() {
            var checkbox = document.getElementById("vehicle3");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Gender');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Gender');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeCigarettes() {
            var checkbox = document.getElementById("vehicle2");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Smoking Status');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Smoking Status');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeStage() {
            var checkbox = document.getElementById("vehicle4");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Stage');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Stage');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeType() {
            var checkbox = document.getElementById("vehicle5");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('type');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('type');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Attach event listener to the checkbox
        document.getElementById("vehicle1").addEventListener("change", handleCheckboxChange);
        document.getElementById("vehicle3").addEventListener("change", handleCheckboxChangeGender);
        document.getElementById("vehicle2").addEventListener("change", handleCheckboxChangeCigarettes);
        document.getElementById("vehicle4").addEventListener("change", handleCheckboxChangeStage);
        document.getElementById("vehicle5").addEventListener("change", handleCheckboxChangeType);

        var radioContainer = document.getElementById("radiobox");

        radioContainer.addEventListener("click", function (event) {
            var selectedRadio = event.target;
            var radioInput = selectedRadio.querySelector('input[type="radio"]');

            //console.log("value = ", radioInput.value)
            if (radioInput && radioInput.type === "radio") {
                console.log(radioInput.value);

                selectedVariable = radioInput.value;

                console.log("Geneselected order in radio:", selectedGeneData);
                console.log("Metadata order in radio:", first_dims);
                console.log("Total order in radio:", ordering);

                updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
            }
        });



        function updateCounter() {
            // Select the counter div
            var counterDiv = d3.select("#counter");
            var counterDiv1 = d3.select("#counter1");

            // Update the content of the counter and apply margin-left to text
            counterDiv.html(
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Total number of genes:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + data_original.length + "</span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Genes filtered by IQR:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + data_copy1.length + "</span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Genes filtered by FC:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + data_copy.length + "</span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Genes filtered by p-val:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + data_copy_pval.length + "</span>"
            );

            counterDiv1.html(
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Parameters</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'> </span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>IQR threshold:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + thr_prc.toFixed(3) + "</span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Log FC threshold:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                "<span style='display: inline-block; width: 180px; margin-left: 20px;'>Significance level:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: left;'>" + threshold + "</span>"
            );
        }

    </script>

    <div id="tooltip"
        style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px;"></div>
    <div id="tTestResults"></div>

</body>

</html>